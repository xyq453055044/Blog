/*
 Navicat Premium Data Transfer

 Source Server         : kaixin
 Source Server Type    : MySQL
 Source Server Version : 50717
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50717
 File Encoding         : 65001

 Date: 07/07/2019 23:34:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ab_blog
-- ----------------------------
DROP TABLE IF EXISTS `ab_blog`;
CREATE TABLE `ab_blog`  (
  `ab_blog_id` tinyint(2) UNSIGNED NOT NULL AUTO_INCREMENT,
  `ab_blog_intro` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `ab_blog_modify_time` datetime(0) DEFAULT NULL,
  PRIMARY KEY (`ab_blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ab_blog
-- ----------------------------
INSERT INTO `ab_blog` VALUES (1, '<p>学习使我快乐是一个由SSM开发的个人博客网站，诞生于2018年12月.其中一部分页面是博主从网上下载的前端代码，并进行了一定的修改；一部分页面是博客自己写的，然后添加后端功能。本站的目的是博主想自己开发一个个人博客网站，记录下自己所学，同时也在以后添加自己想要的功能</p>', '2019-01-13 17:01:53');

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `a_id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `id` bigint(20) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `category` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `personal` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_time` datetime(0) DEFAULT NULL,
  `page_view` int(11) DEFAULT NULL,
  `comment_num` int(255) DEFAULT NULL,
  `recommend` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '',
  PRIMARY KEY (`a_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 31 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 21, '梦见高中班主任', '<p>我记得最搞笑的一个是我在上课的时候做的\r\n　　那时候高中 班主任是一个特别瘦小的男人 身高一米六那种\r\n　　然后班里有一个特别壮的女的\r\n　　身高一米七 体重一百七那种\r\n　　然后我梦到我们班主任带我们出去郊游\r\n　　玩的好开心了\r\n　　要过一条河\r\n　　结果河上面只有条特别小的木板桥\r\n　　我们班姑娘多不敢过\r\n　　班主任就一个一个背我们过去\r\n　　然后最后背那个胖姑娘的时候\r\n　　所有人都在对面看着班主任费力的背着那姑娘\r\n　　背到桥中间的时候 桥塌了哈哈哈\r\n　　他两人都掉进水里了哈哈哈\r\n　　前后我们笑疯了\r\n　　然后我就笑醒了\r\n　　醒了发现我还趴在课桌上哈哈哈</p><img src=\"/images/image/20180109/20180109170010_505.png\" alt=\"\" />', 'Java开发', '0', '2018-12-19 20:42:31', 3, 1, '1');
INSERT INTO `article` VALUES (2, 21, '五种方式让你在java中读取properties文件内容不再是难题', '<h3 style=\"font-family:微软雅黑, 宋体, 黑体, Arial;font-size:16px;font-weight:normal;background:#EEEEEE;color:red;text-align:justify;\">\r\n	一、背景\r\n</h3>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	最近，在项目开发的过程中，遇到需要在properties文件中定义一些自定义的变量，以供java程序动态的读取，修改变量，不再需要修改代码的问题。就借此机会把Spring+SpringMVC+Mybatis整合开发的项目中通过java程序读取properties文件内容的方式进行了梳理和分析，现和大家共享。\r\n</p>\r\n<h3 style=\"font-family:微软雅黑, 宋体, 黑体, Arial;font-size:16px;font-weight:normal;background:#EEEEEE;color:red;text-align:justify;\">\r\n	二、项目环境介绍\r\n</h3>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; Spring&nbsp;4.2.6.RELEASE\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; SpringMvc&nbsp;4.2.6.RELEASE\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; Mybatis&nbsp;3.2.8\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; Maven 3.3.9\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; Jdk 1.7\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	&nbsp; &nbsp; Idea 15.04\r\n</p>\r\n<h3 style=\"font-family:微软雅黑, 宋体, 黑体, Arial;font-size:16px;font-weight:normal;background:#EEEEEE;color:red;text-align:justify;\">\r\n	三、五种实现方式\r\n</h3>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	<strong><span style=\"color:#FF0000;\">方式1</span><span style=\"color:#FF0000;\">.通过context:property-placeholder加载配置文件jdbc.properties中的内容</span></strong>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">context:property-placeholder </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">location</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"classpath:jdbc.properties\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> ignore-unresolvable</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"true\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">/&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	上面的配置和下面配置等价，是对下面配置的简化\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">id</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"propertyConfigurer\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> class</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"ignoreUnresolvablePlaceholders\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"true\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">/&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"locations\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">list</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span>classpath:jdbc.properties<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">list</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	注意：这种方式下，如果你在spring-mvc.xml文件中有如下配置，则一定不能缺少下面的红色部分，关于它的作用以及原理，参见另一篇博客：<span><span style=\"color:#FF0000;\"><strong><a id=\"homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0\" class=\"postTitle2\" href=\"http://www.cnblogs.com/hafiz/p/5875770.html\" target=\"_blank\"><span style=\"color:#FF0000;\">context:component-scan标签的use-default-filters属性的作用以及原理分析</span></a></strong></span></span>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre>&lt;!-- 配置组件扫描，springmvc容器中只扫描Controller注解 --&gt;\r\n&lt;context:component-scan base-<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span>=\"com.hafiz.www\" <span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">use-default-filters=\"false\"</span>&gt;\r\n    &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\r\n&lt;/context:component-scan&gt;</pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	<strong><span style=\"color:#FF0000;\">方式2</span><span style=\"color:#FF0000;\"><strong>.</strong>使用注解的方式注入，主要用在java代码中使用注解注入properties文件中相应的value值</span></strong>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">id</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"prop\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> class</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"org.springframework.beans.factory.config.PropertiesFactoryBean\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">&lt;!--</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> 这里是PropertiesFactoryBean类，它也有个locations属性，也是接收一个数组，跟上面一样 </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">--&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"locations\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">array</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span>classpath:jdbc.properties<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">array</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	<span style=\"color:#FF0000;\"><strong>方式3.使用util:properties标签进行暴露properties文件中的内容</strong></span>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">util:properties </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">id</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"propertiesReader\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> location</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"classpath:jdbc.properties\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">/&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	注意：使用上面这行配置，需要在spring-dao.xml文件的头部声明以下红色的部分\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">beans </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">xmlns</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"http://www.springframework.org/schema/beans\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\"> xmlns:xsi</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\"> xmlns:context</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"http://www.springframework.org/schema/context\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> xmlns:util=\"http://www.springframework.org/schema/util\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\"> xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context-3.2.xsd <span style=\"color:#FF0000;line-height:1.5 !important;\">http://www.springframework.org/schema/util </span> <span style=\"color:#FF0000;line-height:1.5 !important;\"> http://www.springframework.org/schema/util/spring-util.xsd\"</span></span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	<strong><span style=\"color:#FF0000;\">方式4.通过PropertyPlaceholderConfigurer在加载上下文的时候暴露properties到自定义子类的属性中以供程序中使用</span></strong>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">id</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"propertyConfigurer\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> class</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"com.hafiz.www.util.PropertyConfigurer\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"ignoreUnresolvablePlaceholders\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"true\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">/&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"ignoreResourceNotFound\"</span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\"> value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"true\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">/&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property </span><span style=\"color:#FF0000;font-family:&quot;line-height:1.5 !important;\">name</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">=\"locations\"</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">list</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span>classpath:jdbc.properties<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">value</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">list</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">property</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&lt;/</span><span style=\"color:#800000;font-family:&quot;line-height:1.5 !important;\">bean</span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">&gt;</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	自定义类PropertyConfigurer的声明如下:\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.util; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.BeansException; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.factory.config.ConfigurableListableBeanFactory; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.factory.config.PropertyPlaceholderConfigurer; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> java.util.Properties; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * Desc:properties配置文件读取类\r\n * Created by hafiz.zhang on 2016/9/14. </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span> PropertyConfigurer <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">extends</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyPlaceholderConfigurer { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span> Properties props; <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">//</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> 存取properties配置文件key-value结果</span> <span style=\"font-family:&quot;line-height:1.5 !important;\"> @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">protected</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">void</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">throws</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> BeansException { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">super</span><span style=\"font-family:&quot;line-height:1.5 !important;\">.processProperties(beanFactoryToProcess, props); </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">this</span>.props =<span style=\"font-family:&quot;line-height:1.5 !important;\"> props;\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperty(String key){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">this</span><span style=\"font-family:&quot;line-height:1.5 !important;\">.props.getProperty(key);\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperty(String key, String defaultValue) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">this</span><span style=\"font-family:&quot;line-height:1.5 !important;\">.props.getProperty(key, defaultValue);\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> Object setProperty(String key, String value) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">this</span><span style=\"font-family:&quot;line-height:1.5 !important;\">.props.setProperty(key, value);\r\n    }\r\n}</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	使用方式：在需要使用的类中使用@Autowired注解注入即可。\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	<strong><span style=\"color:#FF0000;\">方式5.自定义工具类PropertyUtil，并在该类的static静态代码块中读取properties文件内容保存在static属性中以供别的程序使用</span></strong>\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.util; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.slf4j.Logger; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.slf4j.LoggerFactory; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span> java.io.*<span style=\"font-family:&quot;line-height:1.5 !important;\">; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> java.util.Properties; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * Desc:properties文件获取工具类\r\n * Created by hafiz.zhang on 2016/9/15. </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyUtil { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">final</span> Logger logger = LoggerFactory.getLogger(PropertyUtil.<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span><span style=\"font-family:&quot;line-height:1.5 !important;\">); </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> Properties props; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span><span style=\"font-family:&quot;line-height:1.5 !important;\">{\r\n        loadProps();\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">synchronized</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">void</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> loadProps(){\r\n        logger.info(</span>\"开始加载properties文件内容.......\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n        props </span>= <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">new</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> Properties();\r\n        InputStream in </span>= <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">null</span><span style=\"font-family:&quot;line-height:1.5 !important;\">; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">try</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> {\r\n　　　　　　　&lt;!--第一种，通过类加载器进行获取properties文件流--&gt;\r\n            in </span>= PropertyUtil.<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span>.getClassLoader().getResourceAsStream(\"jdbc.properties\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n　　　　　　  &lt;!--第二种，通过类进行获取properties文件流--&gt; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">//</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">in = PropertyUtil.class.getResourceAsStream(\"/jdbc.properties\");</span> <span style=\"font-family:&quot;line-height:1.5 !important;\"> props.load(in);\r\n        } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">catch</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> (FileNotFoundException e) {\r\n            logger.error(</span>\"jdbc.properties文件未找到\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n        } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">catch</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> (IOException e) {\r\n            logger.error(</span>\"出现IOException\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n        } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">finally</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">try</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">if</span>(<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">null</span> !=<span style=\"font-family:&quot;line-height:1.5 !important;\"> in) {\r\n                    in.close();\r\n                }\r\n            } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">catch</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> (IOException e) {\r\n                logger.error(</span>\"jdbc.properties文件流关闭出现异常\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n            }\r\n        }\r\n        logger.info(</span>\"加载properties文件内容完成...........\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n        logger.info(</span>\"properties文件内容：\" +<span style=\"font-family:&quot;line-height:1.5 !important;\"> props);\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperty(String key){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">if</span>(<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">null</span> ==<span style=\"font-family:&quot;line-height:1.5 !important;\"> props) {\r\n            loadProps();\r\n        } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> props.getProperty(key);\r\n    } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">static</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperty(String key, String defaultValue) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">if</span>(<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">null</span> ==<span style=\"font-family:&quot;line-height:1.5 !important;\"> props) {\r\n            loadProps();\r\n        } </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> props.getProperty(key, defaultValue);\r\n    }\r\n}</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	说明：这样的话，在该类被加载的时候，它就会自动读取指定位置的配置文件内容并保存到静态属性中，高效且方便，一次加载，可多次使用。\r\n</p>\r\n<h3 style=\"font-family:微软雅黑, 宋体, 黑体, Arial;font-size:16px;font-weight:normal;background:#EEEEEE;color:red;text-align:justify;\">\r\n	四、注意事项及建议\r\n</h3>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	以上五种方式，前三种方式比较死板，而且如果你想在带有@Controller注解的Bean中使用，你需要在SpringMVC的配置文件spring-mvc.xml中进行声明，如果你想在带有@Service、@Respository等非@Controller注解的Bean中进行使用，你需要在Spring的配置文件中spring.xml中进行声明。原因请参见另一篇博客：<span><strong><span style=\"color:#FF0000;\"><a id=\"homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1\" class=\"postTitle2\" href=\"http://www.cnblogs.com/hafiz/p/5875740.html\"><span style=\"color:#FF0000;\">Spring和SpringMVC父子容器关系初窥</span></a></span></strong></span>\r\n</p>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	我个人比较建议第四种和第五种配置方式，第五种为最好，它连工具类对象都不需要注入，直接调用静态方法进行获取，而且只一次加载，效率也高。而且前三种方式都不是很灵活，需要修改@Value的键值。\r\n</p>\r\n<h3 style=\"font-family:微软雅黑, 宋体, 黑体, Arial;font-size:16px;font-weight:normal;background:#EEEEEE;color:red;text-align:justify;\">\r\n	五、测试验证是否可用\r\n</h3>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	1.首先我们创建PropertiesService\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.service; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * Desc:java程序获取properties文件内容的service\r\n * Created by hafiz.zhang on 2016/9/16. </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">interface</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertiesService { </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第一种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFirstWay(); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第二种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyBySecondWay(); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第三种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByThirdWay(); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第四种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> key\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFourthWay(String key); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第四种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> key\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> defaultValue\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFourthWay(String key, String defaultValue); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第五种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> key\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFifthWay(String key); </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * 第五种实现方式获取properties文件中指定key的value\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> key\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@param</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> defaultValue\r\n     *\r\n     * </span><span style=\"color:#808080;font-family:&quot;line-height:1.5 !important;\">@return</span> <span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFifthWay(String key, String defaultValue);\r\n}</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	2.创建实现类PropertiesServiceImpl\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.service.impl; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.service.PropertiesService; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.util.PropertyConfigurer; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.util.PropertyUtil; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.factory.annotation.Autowired; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.factory.annotation.Value; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.stereotype.Service; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * Desc:java程序获取properties文件内容的service的实现类\r\n * Created by hafiz.zhang on 2016/9/16. </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> @Service </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span> PropertiesServiceImpl <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">implements</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertiesService {\r\n\r\n    @Value(</span>\"${test}\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String testDataByFirst;\r\n\r\n    @Value(</span>\"#{prop.test}\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String testDataBySecond;\r\n\r\n    @Value(</span>\"#{propertiesReader[test]}\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String testDataByThird;\r\n\r\n    @Autowired </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyConfigurer pc;\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFirstWay() { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> testDataByFirst;\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyBySecondWay() { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> testDataBySecond;\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByThirdWay() { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> testDataByThird;\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFourthWay(String key) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> pc.getProperty(key);\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFourthWay(String key, String defaultValue) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> pc.getProperty(key, defaultValue);\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFifthWay(String key) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyUtil.getPropery(key);\r\n    }\r\n\r\n    @Override </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getProperyByFifthWay(String key, String defaultValue) { </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyUtil.getProperty(key, defaultValue);\r\n    }\r\n}</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	3.控制器类PropertyController\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">package</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.controller; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.service.PropertiesService; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> com.hafiz.www.util.PropertyUtil; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.beans.factory.annotation.Autowired; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.stereotype.Controller; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.web.bind.annotation.PathVariable; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.web.bind.annotation.RequestMapping; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.web.bind.annotation.RequestMethod; </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">import</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> org.springframework.web.bind.annotation.ResponseBody; </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">/**</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\"> * Desc:properties测试控制器\r\n * Created by hafiz.zhang on 2016/9/16. </span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">*/</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> @Controller\r\n@RequestMapping(</span>\"/prop\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> <span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">class</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertyController {\r\n    @Autowired </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">private</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> PropertiesService ps;\r\n\r\n    @RequestMapping(value </span>= \"/way/first\", method =<span style=\"font-family:&quot;line-height:1.5 !important;\"> RequestMethod.GET)\r\n    @ResponseBody </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getPropertyByFirstWay(){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> ps.getProperyByFirstWay();\r\n    }\r\n\r\n    @RequestMapping(value </span>= \"/way/second\", method =<span style=\"font-family:&quot;line-height:1.5 !important;\"> RequestMethod.GET)\r\n    @ResponseBody </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getPropertyBySecondWay(){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> ps.getProperyBySecondWay();\r\n    }\r\n\r\n    @RequestMapping(value </span>= \"/way/third\", method =<span style=\"font-family:&quot;line-height:1.5 !important;\"> RequestMethod.GET)\r\n    @ResponseBody </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> String getPropertyByThirdWay(){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> ps.getProperyByThirdWay();\r\n    }\r\n\r\n    @RequestMapping(value </span>= \"/way/fourth/{key}\", method =<span style=\"font-family:&quot;line-height:1.5 !important;\"> RequestMethod.GET)\r\n    @ResponseBody </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> String getPropertyByFourthWay(@PathVariable(\"key\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) String key){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span> ps.getProperyByFourthWay(key, \"defaultValue\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n    }\r\n\r\n    @RequestMapping(value </span>= \"/way/fifth/{key}\", method =<span style=\"font-family:&quot;line-height:1.5 !important;\"> RequestMethod.GET)\r\n    @ResponseBody </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">public</span> String getPropertyByFifthWay(@PathVariable(\"key\"<span style=\"font-family:&quot;line-height:1.5 !important;\">) String key){ </span><span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">return</span> PropertyUtil.getProperty(key, \"defaultValue\"<span style=\"font-family:&quot;line-height:1.5 !important;\">);\r\n    }\r\n}</span></pre>\r\n</div>\r\n<p style=\"color:#505050;font-family:&quot;font-size:14px;text-align:justify;background-color:#FFFFFF;\">\r\n	4.jdbc.properties文件\r\n</p>\r\n<div class=\"cnblogs_code\" style=\"margin:5px 0px;padding:0px;background-color:#F5F5F5;border:1px solid #CCCCCC;text-align:justify;font-family:&quot;\">\r\n<pre>jdbc.driver=<span style=\"font-family:&quot;line-height:1.5 !important;\">com.mysql.jdbc.Driver\r\njdbc.url</span>=jdbc:mysql:<span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">//</span><span style=\"color:#008000;font-family:&quot;line-height:1.5 !important;\">192.168.1.196:3306/dev?useUnicode=true&amp;characterEncoding=UTF-8</span> jdbc.username=<span style=\"font-family:&quot;line-height:1.5 !important;\">root\r\njdbc.password</span>=123456<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.maxActive</span>=200<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.minIdle</span>=5<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.initialSize</span>=1<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.maxWait</span>=60000<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.timeBetweenEvictionRunsMillis</span>=60000<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.minEvictableIdleTimeMillis</span>=300000<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.validationQuery</span>=select 1<span style=\"font-family:&quot;line-height:1.5 !important;\"> from t_user\r\njdbc.testWhileIdle</span>=<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">true</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.testOnReturn</span>=<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">false</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.poolPreparedStatements</span>=<span style=\"color:#0000FF;font-family:&quot;line-height:1.5 !important;\">true</span><span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.maxPoolPreparedStatementPerConnectionSize</span>=20<span style=\"font-family:&quot;line-height:1.5 !important;\"> jdbc.filters</span>=<span style=\"font-family:&quot;line-height:1.5 !important;\">stat\r\n#test data\r\ntest</span>=com.hafiz.www</pre>\r\n</div>', '人工智能', '0', '2018-12-19 20:45:11', 4, 0, '1');
INSERT INTO `article` VALUES (3, 21, '深夜的思考', '<p>\r\n	人生如梦，想过去的种种。。。\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180109/20180109153802_373.png\" alt=\"\" />', 'Java开发', '0', '2018-12-20 21:45:11', 2, 2, '0');
INSERT INTO `article` VALUES (4, 21, '关于步步高的梦', '<p>\r\n	我梦见以前的老师因为没交作业，让我们几个跳《步步高》的舞蹈，然后让隔壁班没交作业的同学表演时装秀，然后我们两个班比赛…… \r\n我觉得好荒唐，还跳《步步高》呢，给我们准备了不少道具，我们居然也跳了，真是蠢的可以 \r\n请问这个梦代表什么啊，不过我在做这个梦的时候还是很开心的<img src=\"css/zui/lib/kindeditor/plugins/emoticons/images/13.gif\" border=\"0\" alt=\"\" />\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180109/20180109154149_473.png\" alt=\"\" />\r\n</p>', '人工智能', '0', '2018-12-20 21:45:11', 0, 0, '0');
INSERT INTO `article` VALUES (5, 21, '梦见男神', '<p>\r\n	我梦见男神给我表白，然后我们在一起了，醒来以后兴致冲冲的给他发了一个早，他说，我和我对象聊天呢！\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180109/20180109155330_24.png\" alt=\"\" />\r\n</p>', 'Java开发', '0', '2018-12-07 11:45:11', 1, 0, '0');
INSERT INTO `article` VALUES (6, 21, '干豆腐', '范德萨<img src=\"css/zui/lib/kindeditor/plugins/emoticons/images/30.gif\" border=\"0\" alt=\"\" />', '人工智能', '0', '2018-12-05 11:45:11', 0, 0, '0');
INSERT INTO `article` VALUES (7, 21, '梦见会开车', '<p>\r\n	我做梦自己会开车了，但是不知道咋停车，开到一个下坡停不下来了眼看要撞墙了，踩刹车也停不下来，还在往下滑，旁边还停着车咋办啊，急死我了，这时候我急中生智，把车门打开，脚伸到外面，脚踩地上，下坡滑行，用脚和地面产生摩擦，就像骑自行车那样，然后方向盘一打，车稳稳的和旁边那辆并排停在了一起，哈哈哈。/:no完美/:no\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180109/20180109154413_551.png\" alt=\"\" />\r\n</p>', 'Java开发', '0', '2018-11-05 11:45:11', 3, 0, '1');
INSERT INTO `article` VALUES (8, 21, '惊悚古老小镇', '<p>\r\n	梦见一家人出去旅游。然后是那种特别特别古老小城吧。住了一家客栈，然后很古色古香，但是老板贼古怪。然后我记不清发生了什么，反正最后只剩下我和我哥。直接哭醒的。而且很可怕的是，本来梦应该是乱七八糟不切合实际的但他特别特别的有连贯性而且很正常\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180109/20180109204644_109.png\" alt=\"\" />\r\n</p>', 'MySql', '0', '2019-01-05 11:45:11', 49, 3, '0');
INSERT INTO `article` VALUES (9, 21, '梦中惊醒', '<span style=\"color:#333333;font-family:&quot;font-size:14px;background-color:#FFFFFF;\">昨天晚上三点被梦惊醒。</span><br />\r\n<span style=\"color:#333333;font-family:&quot;font-size:14px;background-color:#FFFFFF;\">梦里三个人，先出现我和对面一个男的，手里各拿几把手术剪刀✂️，互相喊什么忘记了，他扔了一把过来我躲过去了，我向他扔了一把命中腹部，但没有看到有流血。忽然对面探出另一个男人，飞出一把手术刀过来，直接划破我的右侧颈部，血开始喷，我左手用力压制着，噗噗冒血，我往后退……</span><br />\r\n<span style=\"color:#333333;font-family:&quot;font-size:14px;background-color:#FFFFFF;\">被惊醒……梦里的人总感觉见过……但又想不起来是谁……</span><br />\r\n<p>\r\n	<span style=\"color:#333333;font-family:&quot;font-size:14px;background-color:#FFFFFF;\">看了下时间三点钟，上了趟厕所，又去睡了，但一直没睡好</span>\r\n</p>\r\n<p>\r\n	<span style=\"color:#333333;font-family:&quot;font-size:14px;background-color:#FFFFFF;\"><img src=\"/images/image/20180223/20180223171820_513.jpg\" alt=\"\" /><br />\r\n</span>\r\n</p>', '人工智能', '0', '2018-10-05 11:45:11', 2, 0, '1');
INSERT INTO `article` VALUES (11, 21, '孤独求败', '<p>\r\n	无敌是多么 多么寂寞\r\n</p>\r\n<p>\r\n	<img src=\"/images/image/20180207/20180207164445_694.png\" alt=\"\" />\r\n</p>', 'MySql', '0', '2018-10-06 11:45:11', 0, 0, '0');
INSERT INTO `article` VALUES (12, 21, '设计模式', '<ol><li>设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>设计原则2：针对接口编程，而不是针对实现编程。（针对接口编程真正的意思是针对超类型（supertype）编程。而针对超类型编程这句话，可以更明确地说成：变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。）</li><li> 设计原则3：多用组合，少用继承。（使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可）</li><li>策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li><li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。（改变主题或观察者的一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由得改变他们。）</li><li>设计原则4：为了交互对象之间的松耦合设计而努力。</li><li>观察者模式中的设计原则挑战：</li><ol><li>在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这就叫提前规划。（对应设计原则1）</li><li>主题与观察者都是用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点。（对应设计原则2）</li><li>观察者模式利用“组合”将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。（对应设计原则3）</li></ol><li>设计原则5（开闭原则）：类应该对扩展开放，对修改关闭。</li><li>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</li><li>装饰者模式的缺点：</li><ol><li>装饰者会导致设计中出现许多小对象（小类），如果过度使用，会让程序变得很复杂；</li><li>采用装饰者在实例化组件时，将增加代码的复杂度。一旦使用装饰者模式，不只需要实例化组件，还要把此组件包装进装饰者中，数量可能有许多许多；</li></ol><li>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</li><li>设计原则6（依赖倒置原则）：要依赖抽象，不要依赖具体类。</li><li>下面的指导方针，能帮你避免在OO设计中违反依赖倒置原则：</li><ol><li>变量不可以持有具体类的引用；（如果使用new，就会持有具体类的引用，可以改用工厂来避开这样的做法）</li><li>不要让类派生自具体类；（如果派生自具体类，就会依赖具体类。请派生自一个抽象）</li><li>不要覆盖基类中已实现的方法。（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）。</li></ol><li>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li><li>单例模式：确保一个类只有一个实例，并提供一个全局访问点。</li><li>命令模式：将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。（当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式）</li><ol><li>命令模式将发出请求的对象和执行请求的对象解耦；</li><li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作；</li><li>调用者通过调用命令对象的execute()发出请求，这会使得接受者的动作被调用；</li><li>调用者可以接受命令当做参数，甚至在运行时动态地进行；</li><li>命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行之前的状态(或者使用一个堆栈，记录每一个执行的命令的动作，当需要撤销时，依次出栈执行对应动作的相反动作)</li></ol><li>命令模式的总结：</li><ol><li>命令模式的主要目的是将发出请求的对象和执行请求的对象解耦；</li><li>命令模式包含调用者，接受者和命令接口。</li><li>调用者持有一个命令对象，并在某个时间点调用命令对象的execute()方法，将请求付诸实行；（调用者相当于遥控器，按下上面的按钮就是具体的调用某个命令对象的execute()方法，执行调用；命令对象可以通过调用者的构造函数或者调用者的设置命令的方法传递进去）</li><li>接受者知道如何进行必要的工作，实现这个请求。任何类都可以当接受者。（接受这就相当于遥控器控制的某个家电，该家电类中有许多的函数，对应遥控器上的操作，比如开，关等。但是遥控器（调用者）并不是直接的控制家电（接受者），而是通过命令来控制，这样做的好处就是将调用者和接受者实现解耦，设计符合开闭原则）</li><li>命令接口：在命令接口中有两个抽象方法，执行命令的方法和撤销命令的方法。针对不同的家电拥有不同的命令行为，所有针对不用的家电的命令都要实现这个接口。遥控器要控制某个家电，就在构造器或使用set方法将自己所持有的命令对象实例化，然后在遥控器的内部实现某个方法，比如按下灯开的方法，在该方法内部调用该命令对象的execute()方法，执行开灯的命令。在命令接口子类的实例化过程中，将具体的接受者传递进去，这样当调用者执行相应的方法的时候，就知道接受者是谁，会做出怎样的反应。</li><li>当来一个新的接受者时，定义一个命令子类，在子类的execute()方法中调用具体的接受者的行为，然后将子类的对象传入到调用者中，具有良好的可扩展性。</li></ol></ol><p><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/60e980bf355f49a3b2fa6c9ba9f8ad24/image1.png\"></p><ol><li>适配器模式：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li><li>适配器模式将一个或多个类接口变成客户所期望的一个接口。外观不只是简化了接口，也将客户从组件的子系统中解耦。</li><li>外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口。</li><li>外观模式：提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</li><li>设计原则7（最少知识原则）：只和你的蜜友谈话（最少知识原则告诉我们要减少对象之间的交互，只留下几个“蜜友”）</li><li>就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围内的方法：</li><ol><li>该对象本身</li><li>被当做方法的参数而传递进来的对象</li><li>此方法所创建或实例化的任何对象</li><li>对象的任何组件</li></ol></ol><p>前3条告诉我们：如果某对象是调用其它的方法的返回结果，不要调用该对象的方法。</p><p>最后一条：把“组件”想象成是被实例变量所引用的任何对象，换句话说，把这想象成“有一个（has a）”关系。</p><ol><li>适配器模式和外观模式要点：</li><ol><li>当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。</li><li>但需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>适配器改变接口以符合客户的期望；外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>适配器将一个对象包装起来以改变其接口；装饰器将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。</li></ol><li>适配器模式总结：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间：两个接口A和B，一个适配器类，若将A适配成B，则将适配器类实现B接口，那么适配器类就具有与B相似的性质，在适配器类中声明一个A对象，然后再构造器中传入A的对象，在适配器实现的B的方法中，调用A的方法，这样就可以使用适配器类，像是用B类型一样使用A类型。</li><li>外观模式总结：外观模式的主要目的是让接口更加的简单，它提供一个外观类，将复杂的子系统包装起来仅对外提供更少的接口，让系统使用起来更加的简单。虽然提供简单的接口，但是系统的复杂功能依然也会暴露出来，供用户使用更加复杂的功能。比方说，若干一件事要进行若干的步骤，那么我们可以使用一个外观类将这若干步骤包装起来，使用的时候只需要一个步骤就是“启动”，那么这若干步骤就会自动的有序的开始。这就是外观模式。</li><li>模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。（这个模式的重点在于：提供一个算法，并让子类实现某些步骤）</li><li>钩子方法在抽象类中有默认的实现，子类可以选择去实现。钩子方法的目的是：钩子可以让子类实现算法中可选部分，或者在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理。钩子的另一个用法，是让子类能够有机会对模板方法中的某些即将发生的（或刚刚发生的）步骤做出反应。比方说，名为justReOrderedList()钩子方法允许子类在内部列表重新组织后执行某些动作（例如在屏幕上重新显示数据）。钩子也可以让子类有能力为其抽象类作一些决定。</li><li>设计原则8（好莱坞原则）：别调用（打电话给）我们，我们会调用（打电话给）你。</li><li>好莱坞原则和依赖倒置原则之间的关系：依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。而好莱坞原则是用在创建框架或组件上的一种技巧，好让底层组件能够被挂钩进计算中，而且又不会让高层组件依赖底层组件。两者的目标都是在于解耦，但是依赖倒置原则更加注重如何在设计中避免依赖。好莱坞原则教我们一个技巧，创建一个有弹性的设计，允许底层结构能够互相操作，而又防止其他类太过依赖它们。</li><li>底层组件对高层组件中的方法的调用：底层组件在结束时，常常会调用从超类中继承类的方法。我们所要做的是，避免让高层和底层组件之间有明显的环状依赖。</li><li>模板方法的要点：</li><ol><li>模板方法定义了算法的步骤，把这些步骤的实现延迟到子类；</li><li>模板方法模式为我们提供了一种代码复用的重要技巧；</li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子；</li><li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它；</li><li>为了防止子类改变模板方法中的算法，可以将模板方法声明为final；</li><li>好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块；</li><li>你将在真是代码世界中看到模板方法模式的许多变体，不要期待它们全部都是一眼就可以被你认出的；</li><li>策略模式和模板方法模式都封装算法，一个用组合，一个用继承；</li><li>工厂方法是模板方法的一种特殊版本。</li></ol><li>模板方法总结：模板方法是定义在抽象类中的方法，该方法中有具体的步骤，这些步骤都是固定不变，由具体的行为对象或子类调用。在模板方法所在的抽象类中，有抽象方法，具体的方法，和钩子方法。这些方法都是模板方法中使用的方法，其中抽象方法是子类必须实现的方法，该方法表示不同子类的不同属性或行为；具体方法，是子类通用的方法，若不想子类覆盖此方法，可以设为final；钩子方法在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它；</li><li>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</li><ol><li>迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示</li><li>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</li></ol><li>设计原则9（单一职责原则）：一个类应该只有一个引起变化的原因。</li><li>当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。</li><li>组合模式：允许你见对象组合成树形结结构来表现\"整体/部分\"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</li><ol><li>组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象；</li><li>使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。</li></ol><li>迭代器模式和组合模式的要点：</li><ol><li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构；</li><li>迭代器将遍历聚合的工作封装进一个对象中；</li><li>当使用迭代器的时候，我们依赖聚合提供遍历；</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制；</li><li>我们应该努力让一个类只分配一个责任；</li><li>组合模式提供一个结构，可同时包容个别对象和组合对象；</li><li>组合模式允许客户对个别对象以及组合对象一视同仁；</li><li>组合结构内的任意对象称为组件，组件可以是组合，也可以是叶结点；</li><li>在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性和安全性。</li></ol><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li><li>状态模式要点：</li><ol><li>状态模式允许一个对象基于内部状态而拥有不同的行为；</li><li>模式状态用类代表状态；</li><li>Context会将行为委托给当前状态对象；</li><li>通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了；</li><li>状态模式和策略模式有相同的类图，但是它们的意图不同；</li><li>策略模式通常会用行为或算法来配置Context类；状态模式允许Context随着状态的改变而改变行为；</li><li>状态转换可以由State类或Context类控制；</li><li>使用状态模式通常会导致设计中类的数目大量增加；</li><li>状态类可以被多个Context实例共享。</li><li>将状态转换放在状态类中的缺点是：状态类之间产生了依赖。</li></ol><li>状态模式总结：</li><ol><li>Context是一个类，它可以拥有一些内部的状态，我们的目的就是控制这些内部状态的转换。比如，在Head First第十章的状态模式中的糖果机类（GumballMachine）就是一个Context</li><li>State接口定义了一个所有具体状态的共同接口；任何状态都实现这个相同的接口，这样一来，状态之间可以互相替换。（若状态子类有一些共同的行为，可以将State定义为抽象类，并在抽象类中定义这些共同的行为供子类使用）</li><li>不管在什么时候，只要有人调用了Context的请求状态转换的方法（比如糖果机中投入一枚硬币），就会被委托到状态类来处理</li><li>State的子类具体状态处理来自于Context请求（比方说糖果机的投一枚硬币请求）。每个具体状态类都提供了它自己对于请求的实现。所以，当Context改变状态时行为也跟着改变。</li><li>关于状态模式，主要是一个Context类，用户的所有的请求都由它处理；一个状态（State）接口或抽象类，提供一个所有状态子类的共同接口，这样一来状态子类之间的状态可以互相替换；多个状态子类的实现，主要是用来处理Context的状态改变的请求。类图如下：</li></ol></ol><p style=\"margin-left: 40px;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/d3671a658b4d430e898f830a9f9591b1/clipboard.png\"><img alt=\"image.png\" src=\"data:image/png;base64,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7eW1gSFmtm64u9ig/Jadd9gUXn4zj9fmP8vozs/qcPvN+YCXhs7kXceaVZUMjdTYOLvjbKcsXwhOYTN4+3UDIl98hogeNXNh8HuALdtu0Z1vY2fHoD692BN7nNPlfWirDHStPM3O6BM4OPXExFTfyNf/1uMqrW3dAg9+mcGDjapo33My7++c3HBkygqSp6xo2AcS6k4YPZfN533O+k7/huTpDcnNnbyZueUcMxsOXbAV8X5CkyFZ5t7deeTzRB75/IKkNQcixnHvHcN4flUkn91ljWF+Kqf/OIll4E2Ey1KCF0FrHYcl8G4dj4PUQgREQATw6Dme+T3HN5Hwuv0D9t3ecKjfcztJeK5hv/HW+Pnf0/hslYkF/Z77gS2NErWLiGRFRG0AXXf8/uE8Xrtt5RFE5PLddffo/joNeIA12x9ocqx+x8oW1+5BeHz7PT/su4Xp/a2o+Otn9iX5M/Lp7thYXeF48voMZUMERODyAoOY/dpgBi+Zx5YBc/E5uZddJ9LpMuVGahc5vHwWkqJFBGSoSYuwS6EiIAIicL0IWOLRdig39jNnz8av2H/0KOvXbqW8d0/6t/Woneh+vbRV2iECrUfAd/piZgcf46OVu9m/fRMVIdMZ16duAlrrqafUpKmA9Hg39ZA9ERABERCBvylg5uLHjZPuJv27I8RER1Oo7sHE0Tfi53L+L5/9zYwluQiIwCUEfJi2PIqaKZrnjXe5xFlyV8sKSODdsv5SugiIgAhcBwImuAYN5omgwddBW6QJIiACInD1BGSoydWzlZxFQAREQAREQAREQAREoF5AAu96CtkQAREQAREQAREQAREQgasnIIH31bOVnEVABERABERABERABESgXqDZx3g/88wzLFq0qL4CsnFtCRQVXeGv5F1bzZLaioAIiIAIiIAIiMBVF2j2wPvo0aNXvVFSgAiIgAiIgAiIgAiIgAi0NgEZatLaHhGpjwiIgAiIgAiIgAiIwHUp0Cw93pGRkSj/5CYCIiACIiACIiAClxMoLCwkLy/vcsnkfhG4qgKlpaX/ev7NEnj/67WWDEVABESgmQQqKytJSEhoptKkGBG4uIDyXPyv3Pr37/9faaq08z8mIIH3f+wBl+aKgAj8PYHk5GR8fHz+3kmSWgREQAREQAT0CEjgrQdFDomACIiACIiACDSvQEhICKNGjWreQqU0EbhCAQcHhytMeelkBufOnTt36SRyrwiIgAj89wRmzJiBVqv97zVcWnxNCKxcufKaqKdUUgREoKmABN5NPWRPBERABERABERABERABK6KgCwneFVYJVMREAEREAEREAEREAERaCoggXdTD9kTAREQAREQAREQAREQgasiIIH3VWGVTEVABERABERABERABESgqYAE3k09ZE8EREAEREAEREAEREAEroqABN5XhVUyFQEREAEREAEREAEREIGmAhJ4N/WQPREQAREQAREQAREQARG4KgISeF8VVslUBERABERABERABERABJoKSODd1EP2REAEREAEREAEREAEROCqCEjgfVVYJVMREAEREAEREAEREAERaCoggXdTD9kTAREQAREQAREQAREQgasiIIH3VWGVTEVABERABERABERABESgqYAE3k09ZE8EREAEREAEREAEREAErorA/wNzOfFC/MVB7QAAAABJRU5ErkJggg==\" width=\"734\" height=\"303\"></p><p>42. 状态模式和策略模式比较：</p><ol><li>以状态模式而言，我们将一群行为封装在状态对象中，Context的行为随时可委托到那些状态对象中一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出Context内部的状态，因此，Context的行为也会跟着改变。但是Context的客户对于状态对象了解不多，甚至根本是浑然不觉。</li><li>以策略模式而言，客户通常主动指定Context所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个Context对象来说，通常都只有一个最适当的策略对象。</li><li>一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。有了策略模式，你可以通过组合不同的对象来改变行为。</li><li>我们把状态模式想象成是不用在context中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过在Context内简单地改变状态对象来改变Context的行为。</li></ol>', '设计模式', '0', '2018-12-27 20:27:49', 25, 0, '1');
INSERT INTO `article` VALUES (24, 21, '设计模式类图', '<div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">1. </span><span style=\"font-size: 16px; font-weight: bold;\">策略模式</span><span style=\"font-size: 16px;\">：</span>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。（将客户的同一类型的变化行为封装起来（接口），再通过组合进客户代码中，这样针对不同的行为，可以有不同的实现）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">策略模式示例程序类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img src=\"http://localhost:8080/uploadImg/ed16d28ff2ba46ccaed42b65f30b848c.png\" style=\"max-width:100%;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/85a330e4debc4d308df34dbf48d7839d/clipboard.png\" style=\"width: 408px;\"></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/85a330e4debc4d308df34dbf48d7839d/clipboard.png\" style=\"width: 408px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">策略模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img src=\"http://localhost:8080/uploadImg/d311f776e25649c786d720c8fdad2f86.png\" style=\"max-width:100%;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/ab0594612f554f3d8cfae46ddd5c6dd4/clipboard.png\" style=\"width: 320px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">策略模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">优点</div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">每个算法单独封装，减少了算法和算法调用者的耦合。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">合理使用继承有助于提取出算法中的公共部分。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">简化了单元测试。</li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">缺点</div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">策略模式只适用于客户端知道所有的算法或行为的情况。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">策略模式造成很多的策略类，每个具体策略类都会产生一个新类。不过可以使用享元模式来减少对象的数量。</li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">2. 观察者模式：</span>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。（改变主题或观察者的一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由得改变他们。）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">观察者模式类图：</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img src=\"http://localhost:8080/uploadImg/5704b38cf0a6473183dc4d3e71a0e75d.png\" style=\"max-width:100%;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/ec3f3abcf9b04187a39634649ad42158/clipboard.png\" style=\"width: 506px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">观察者模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">1. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，被观察者只知道所有具体观察者都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">2. 观察者模式实现了动态联动（联动：做一个操作引起其它相关操作）。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">3. 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">1. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">2. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">3. 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">4. 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">3. 装饰者模式：</span>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（1）装饰者和被装饰对象有相同的超类型。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（2）你可以用一个或多个装饰者包装一个对象。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（3）既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">可以用装饰过的对象代替它。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（4）装饰者可以在所委托被装饰者的行为之前与<span style=\"font-size: 16px;\">/</span>或之后，加上自己的行为，以达到特定的目的。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（5）对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">对象。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">装饰者模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img src=\"http://localhost:8080/uploadImg/9364c137faac4ed6bbb2321fd03b3b12.png\" style=\"max-width:100%;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/219b415690f54cba8d88e10376213973/clipboard.png\" style=\"width: 465px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">装饰者模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">4. 工厂方法模式：</span>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\">工厂方法类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/c9925256325a4de899e3c82ac0793443/clipboard.png\" style=\"width: 445px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">工厂方法优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">良好的封装性，代码结构清晰，减少模块间的耦合。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">工厂方法模式的扩展性非常优秀。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">屏蔽产品类。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">工厂方法模式是典型的解耦框架。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">使用者必须知道相应工厂的存在。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">5. 抽象工厂模式：</span>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">抽象工厂类图：</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/9344460efe044e3b8502eb57b9c143c3/clipboard.png\" style=\"width: 411px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/1a9e7ebe8d7f4a7b8494677206f0ce92/clipboard.png\" style=\"width: 395px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">抽象工厂的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">1.它分离了具体的类。</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">2.它使得易于交换产品系列</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">3.它有利于产品的一致性</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">1. 抽象工厂模式在于难于应付“新对象”的需求变动，难以支持新种类的产品。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">2. 难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">6. 单例模式：</span>确保一个类只有一个实例，并提供一个全局访问点。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">1、提供了对唯一实例的受控访问。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">2、单例类的职责过重，在一定程度上违背了“单一职责原则”。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">7. 命令模式：</span>将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。（当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\">命令模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/3ece68937d2b4fccbbefc18f0de4a115/clipboard.png\" style=\"width: 466px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><br></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/864c4eae7fa84a36a11c0a84e418e022/image1.png\" style=\"width: 406px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">命令模式的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">（1）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更松散的耦合。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（2）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更动态的控制。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（3）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">很自然的复合命令。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（4）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更好的扩展性。</span><span style=\"background-color: rgb(255, 255, 255);\">由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Verdana; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">（1）使用命令模式可能会导致某些系统有过多的具体命令类。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">8. 适配器模式：</span>将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">适配器模式类图：（1）使用继承  （2）使用委托</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">类图解释：Client不能直接使用adaptee需要使用适配器类Adapter才能使用，而适配器类Adapter实现了适配器接口（继承）。或者继承目标类而使用委托。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">（1）使用继承</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/8afb3b31e7c04288bf9ff56f44206812/clipboard.png\" style=\"width: 418px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">（2）使用委托</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/899382c95f8f4511b7991c34ecb0921f/clipboard.png\" style=\"width: 406px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">   适配器模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">   优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（1）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">将目标类和适配者类解耦。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（2）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">增加了类的透明性和复用性。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一适配者类可以在多个不同的系统中复用。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（3）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">灵活性和扩展性都非常好。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上增加新的适配器，完全复合开闭原则。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　</span><span style=\"font-size: 16px; font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（1）一次最多只能适配一个适配者类，不能同时适配多个适配者。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（2）目标抽象类只能为接口，不能为类，其使用有一定的局限性。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">（3）过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接								    口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">9. 外观模式：</span>提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">外观模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/41c0a1148e8340778b18317f4d3dbdfd/clipboard.png\" style=\"width: 390px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">外观模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249); font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）外观模式对客户端屏蔽了子系统组件，从而简化了接口，减少了客户端处理的对象数目并使子系统的使用更加简单。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户端。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）</span><span style=\"font-size: 13px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">10. 模板方法模式：</span>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。（这个模式的重点在于：提供一个算法，并让子类实现某些步骤）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">模板方法模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/f5dece2856e14e5dab983022e70fb93f/clipboard.png\" style=\"width: 395px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">模板方法优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">提高代码复用性和可扩展性：把认为不变部分的算法封装到父类实现，可变部分则可以通过继承来实现，很容易扩展。（封装不变部分，扩展可变部分）</span></li><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">实现了反向控制：通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制，符合“开闭原则”。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。（但是更加的符合单一职责原则，使得类的内聚性得以提高）</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">11. 迭代器模式：</span>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">迭代器模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/05c05f1f780e48ffbe1f2f8f139c0ea0/clipboard.png\" style=\"width: 397px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">迭代器模式的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过下标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">12. 组合模式：</span>允许你见对象组合成树形结结构来表现\"整体/部分\"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">组合模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/bfe77a3183154b2eae7a709577898169/clipboard.png\" style=\"width: 403px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">组合模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（4）更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">13. 状态模式：</span>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">状态模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/b0e896cc19d148b19ec6a534ddb5e280/clipboard.png\" style=\"width: 404px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">状态模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）封装了转换规则。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）枚举可能的状态，在枚举状态之前需要确定状态种类。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（4）允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（5）可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）状态模式的使用必然会增加系统类和对象的个数。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要					修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">14. 代理模式：</span>为另一个对象提供一个替身或占位符以控制对这个对象的访问。（使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">代理模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/d56f1693341d4145a7413239dfd7e6ac/clipboard.png\" style=\"width: 428px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">代理模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><span style=\"font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（1）</span><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">代理模式能将代理对象与真正被调用的对象分离，在一定程度上降低了系统的耦合度。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（2）</span><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他操作。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）高扩展性：无论被代理对象如何改变，只要代理类和被代理类都实现了统一接口，都不同修改代理类，而且即使扩展了新的被代理类，代理类也可以使用，只要创建代理类的时候传入对应的被代理类对象。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><span style=\"font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（1）在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（2）增加了系统的复杂度。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div>', '设计模式', '0', '2019-01-08 20:11:04', 2, 0, '0');
INSERT INTO `article` VALUES (25, 21, 'ligbm简介', '<p><span style=\"\">一、 前言</span></p><p><span style=\"\">最近在做Kaggle比赛的时候，看到别人的Kenels中都用到了lightgbm，自己也试图用了一下，发现效果很好，最重要的是它相对于XGBoost算法，大大的降低了运行的速度。所以就对Lightgbm的原理探了个究竟，这里就对Lightgbm论文的理解以及对官网上对Lightgbm的介绍做一个学习笔记。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">传统的boosting算法（如GBDT和XGBoost）已经有相当好的效率，但是在如今的大样本和高维度的环境下，传统的boosting似乎在效率和可扩展性上不能满足现在的需求了，主要的原因就是传统的boosting算法需要对每一个特征都要扫描所有的样本点来选择最好的切分点，这是非常的耗时。为了解决这种在大样本高纬度数据的环境下耗时的问题，Lightgbm使用了如下两种解决办法：一是GOSS（Gradient-based One-Side Sampling, 基于梯度的单边采样），不是使用所用的样本点来计算梯度，而是对样本进行采样来计算梯度；二是EFB（Exclusive Feature Bundling， 互斥特征捆绑） ，这里不是使用所有的特征来进行扫描获得最佳的切分点，而是将某些特征进行捆绑在一起来降低特征的维度，是寻找最佳切分点的消耗减少。这样大大的降低的处理样本的时间复杂度，但在精度上，通过大量的实验证明，在某些数据集上使用Lightgbm并不损失精度，甚至有时还会提升精度。下面就主要介绍这两种方法。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">本文的主要内容，首先介绍GOSS和EFB方法，然后再根据Lightgbm官网的介绍，谈一谈Lightgbm的特性以及调参。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">二、Gradient-based One-Side Sampling（GOSS）介绍</span></p><p><span style=\"\">GOSS（基于梯度的单边采样）方法的主要思想就是，梯度大的样本点在信息增益的计算上扮演着主要的作用，也就是说这些梯度大的样本点会贡献更多的信息增益，因此为了保持信息增益评估的精度，当我们对样本进行下采样的时候保留这些梯度大的样本点，而对于梯度小的样本点按比例进行随机采样即可。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">2.1 GOSS算法</span></p><p><span style=\"\">在AdaBoost算法中，我们在每次迭代时更加注重上一次错分的样本点，也就是上一次错分的样本点的权重增大，而在GBDT中并没有本地的权重来实现这样的过程，所以在AdaBoost中提出的采样模型不能应用在GBDT中。但是，每个样本的梯度对采样提供了非常有用的信息。也就是说，如果一个样本点的梯度小，那么该样本点的训练误差就小并且已经经过了很好的训练。一个直接的办法就是直接抛弃梯度小的样本点，但是这样做的话会改变数据的分布和损失学习的模型精度。GOSS的提出就是为了避免这两个问题的发生。下面就是GOSS算法的伪代码：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">下面将对上述算法进行描述。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">2.2 GOSS算法描述</span></p><p><span style=\"\">输入：训练数据，迭代步数d，大梯度数据的采样率a，小梯度数据的采样率b，损失函数和若学习器的类型（一般为决策树）；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">输出：训练好的强学习器；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）根据样本点的梯度的绝对值对它们进行降序排序；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）对排序后的结果选取前a*100%的样本生成一个大梯度样本点的子集；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）对剩下的样本集合（1-a）*100%的样本，随机的选取b*（1-a）*100%个样本点，生成一个小梯度样本点的集合；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）将大梯度样本和采样的小梯度样本合并；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（5）将小梯度样本乘上一个权重系数；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（6）使用上述的采样的样本，学习一个新的弱学习器；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（7）不断地重复（1）~（6）步骤直到达到规定的迭代次数或者收敛为止。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">通过上面的算法可以在不改变数据分布的前提下不损失学习器精度的同时大大的减少模型学习的速率。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">从上面的描述可知，当a=0时，GOSS算法退化为随机采样算法；当a=1时，GOSS算法变为采取整个样本的算法。在许多情况下，GOSS算法训练出的模型精确度要高于随机采样算法。另一方面，采样也将会增加若学习器的多样性，从而潜在的提升了训练出的模型泛化能力。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">三、Exclusive Feature Bundling（EFB）介绍</span></p><p><span style=\"\">Lightgbm实现中不仅进行了数据采样，也进行了特征抽样，使得模型的训练速度进一步的减少。但是该特征抽样又与一般的特征抽样有所不同，是将互斥特征绑定在一起从而减少特征维度。主要思想就是，通常在实际应用中高纬度的数据往往都是稀疏数据（如one-hot编码），这使我们有可能设计一种几乎无损的方法来减少有效特征的数量。尤其，在稀疏特征空间中许多特征都是互斥的（例如，很少同时出现非0值）。这就使我们可以安全的将互斥特征绑定在一起形成一个特征，从而减少特征维度。但是怎样的将互斥特征绑定在一起了？Lightgbm作者使用的是基于直方图（histograms）的方法。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">3.1 EFB算法</span></p><p><span style=\"\">由于将特征划分为更小的互斥绑定数量，这是一个NP-hard问题，即在多项式时间内不可能去找到准确的解决办法。所以这里使用的是一种近似的解决办法，即特征之间允许存在少数的样本点并不是互斥的（如存在某些对应的样本点之间不同时为非0值），允许小部分的冲突可以得到更小的特征绑定数量，更进一步的提高了计算的有效性。在理论上可以证明，通过允许小部分的冲突的话，使得模型的accuracy被影响，这里的是每个绑定的最大冲突率。所以，当我们选择很小的时，我们可以在精确度和效率上获得很好的权衡。下面就是互斥特征绑定（Exclusive Feature Bundling）的算法：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">下面将对上述算法进行描述。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">3.2 EFB算法描述</span></p><p><span style=\"\">输入：特征F，最大冲突数K，图G；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">输出：特征捆绑集合bundles；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）构造一个边带有权重的图，其权值对应于特征之间的总冲突；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）通过特征在图中的度来降序排序特征；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）检查有序列表中的每个特征，并将其分配给具有小冲突的现有bundling（由控制），或创建新bundling。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">上述算法的时间复杂度为并且在模型训练之前仅仅被处理一次即可。在特征维度不是很大时，这样的复杂度是可以接受的。但是当样本维度较高时，这种方法就会特别的低效。所以对于此，作者又提出的另外一种更加高效的算法：按非零值计数排序，这类似于按度数排序，因为更多的非零值通常会导致更高的冲突概率。 这仅仅改变了上述算法的排序策略，所以只是针对上述算法将按度数排序改为按非0值数量排序，其他不变。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">3.3 合并互斥特征</span></p><p><span style=\"\">Lightgbm关于互斥特征的合并用到了直方图（Histogram）算法。直方图算法的基本思想是先把连续的特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">由于基于直方图的算法存储的是离散的bins而不是连续的特征值，我们可以通过让互斥特征驻留在不同的bins中来构造feature bundle。这可以通过增加特征原始值的偏移量来实现。比如，假设我们有两个特征，特征A的取值范围是[0,10)，而特征B的取值范围是[0,20)，我们可以给特征B增加偏移量10，使得特征B的取值范围为[10, 30)，最后合并特征A和B，形成新的特征，取值范围为[0,30)来取代特征A和特征B。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；差一点的切分点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在Gradient Boosting的框架下没有太大的影响。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">Histogram算法有如下的一些优点：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）减少分割增益的计算量：xgboost中默认使用的是pre-sorted算法，需要次的计算，而Histogram算法只需要计算次，并且远小于；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）通过直方图相减来进一步的加速模型的训练：在二叉树中可以通过利用叶节点的父节点和相邻节点的直方图的相减来获得该叶节点的直方图。所以仅仅需要为一个叶节点建立直方图 (其小于它的相邻节点)就可以通过直方图的相减来获得相邻节点的直方图，而这花费的代价（）很小。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）减少内存的使用：可以将连续的值替换为离散的bins。 如果较小, 可以利用较小的数据类型来存储训练数据并且无需为 pre-sorting 特征值存储额外的信息。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）减少并行学习的通信代价。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">我们称使用GOSS算法和EFB算法的梯度提升树（GBDT）称之为LightGBM。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">四、Lightgbm的一些其它特性</span></p><p><span style=\"\">4.1 Leaf-wise的决策树生长策略</span></p><p><span style=\"\">大部分决策树的学习算法通过 level-wise 策略生长树，记一次分裂同一层的叶子，不加区分的对待同一层的叶子，而实际上很多叶子的分裂增益较低没必要进行分裂，带来了没必要的开销。如下图：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">LightGBM 通过 leaf-wise 策略来生长树。每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。但是，当样本量较小的时候，leaf-wise 可能会造成过拟合。 所以，LightGBM 可以利用额外的参数 max_depth 来限制树的深度并避免过拟合。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">4.2 类别特征值的最优分割</span></p><p><span style=\"\">对于类别型的数据，我们通常将类别特征转化为one-hot/哑变量编码。 然而，对于学习树来说这不是个好的解决方案。 原因是，对于一个基数较大的类别特征，学习树会生长的非常不平衡，并且需要非常深的深度才能来达到较好的准确率。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">事实上，最好的解决方案是将类别特征划分为两个子集，总共有种可能的切分。比如有一个颜色特征，每个样本的颜色特征是{红、黄、蓝、绿}四种类别中的一种，如果使用ne-hot/哑变量编码很好理解这里不再叙述，但是如果使用LightGBM的切分策略，就是将红、黄、蓝、绿对应的四类样本分为两类的所有可能策略，比如：红黄一类，蓝绿一类。那么就会有 种策略，这样才能充分的挖掘该维特征所包含的信息，找到最优的分割策略。 但是这样寻找最优分割策略的时间复杂度就会很大。对于回归树有个有效的解决方案。为了寻找最优的划分需要大约&nbsp; 。基本的思想是根据训练目标的相关性对类别进行重排序。 更具体的说，根据累加值()重新对（类别特征的）直方图进行排序，然后在排好序的直方图中寻找最好的分割点。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">4.3 Lightgbm中的并行学习</span></p><p><span style=\"\">4.3.1 特征并行</span></p><p><span style=\"\">1、传统算法的的特征并行</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">传统的特征并行算法旨在于在并行化决策树中的寻找最佳切分点，主要流程如下：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）垂直切分数据（不同的Worker有不同的特征集）；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）在本地特征集寻找最佳切分点 {特征, 阈值}；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）在各个机器之间进行通信，拿出自己的最佳切分点，然后从所有的最佳切分点中推举出一个最好的切分点，作为全局的切分点；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）以最佳划分方法对数据进行划分，并将数据划分结果传递给其他Worker；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（5）其他Worker对接受到的数据进一步划分。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">2、传统的特征并行方法主要不足:</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）存在计算上的局限，传统特征并行无法加速特征切分（时间复杂度为 ）。 因此，当数据量很大的时候，难以加速。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）需要对划分的结果进行通信整合，其额外的时间复杂度约为。（一个数据一个字节）</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">3、LightGBM 中的特征并行</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">在数据量很大时，传统并行方法无法有效地对特征进行并行，LightGBM 做了一些改变：不再垂直划分数据，即每个Worker都持有全部数据。 因此，LighetGBM中没有数据划分结果之间通信的开销，各个Worker都知道如何划分数据。 而且，样本量也不会变得更大，所以，使每个机器都持有全部数据是合理的。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">LightGBM 中特征并行的流程如下：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）每个Worker都在本地特征集上寻找最佳划分点｛特征， 阈值｝；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）本地进行各个划分的通信整合并得到最佳划分；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）执行最佳划分。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">然而，该特征并行算法在数据量很大时仍然存在计算上的局限。因此，建议在数据量很大时使用数据并行。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">4.3.2 数据并行</span></p><p><span style=\"\">1、传统的数据并行算法</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">数据并行目的是并行化整个决策学习过程。数据并行的主要流程如下：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）水平划分数据；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）Worker以本地数据构建本地直方图；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）将所有Worker的本地直方图整合成全局整合图；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）在全局直方图中寻找最佳切分，然后执行此切分。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">2、传统数据并行的不足：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">高通讯开销。 如果使用点对点的通讯算法，一个Worker的通讯开销大约为。 如果使用集体通讯算法（例如， “All Reduce”等），通讯开销大约为。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">3、LightGBM中的数据并行</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">LightGBM 中通过减少数据并行过程中的通讯开销，来减少数据并行的开销：</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（1）不同于传统数据并行算法中的，整合所有本地直方图以形成全局直方图的方式，LightGBM 使用Reduce scatter的方式对不同Worker的不同特征（不重叠的）进行整合。 然后Worker从本地整合直方图中寻找最佳划分并同步到全局的最佳划分中。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）如上面提到的，LightGBM 通过直方图做差法加速训练。 基于此，我们可以进行单叶子的直方图通讯，并且在相邻直方图上使用做差法。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">通过上述方法，LightGBM 将数据并行中的通讯开销减少到。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">4.3.3 投票并行</span></p><p><span style=\"\">投票并行进一步的减少数据并行的的通信消耗为常数级别。它使用两阶段的投票来减少特征直方图的通信消耗。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">五、LightGBM中的主要调节的参数</span></p><p><span style=\"\">5.1 针对 Leaf-wise（Best-first）树的参数优化</span></p><p><span style=\"\">（1）num_leaves这是控制树模型复杂度的主要参数。理论上, 借鉴 depth-wise 树, 我们可以设置 num_leaves=&nbsp; 但是, 这种简单的转化在实际应用中表现不佳. 这是因为, 当叶子数目相同时, leaf-wise 树要比 depth-wise 树深得多, 这就有可能导致过拟合. 因此, 当我们试着调整 num_leaves 的取值时, 应该让其小于 . 举个例子, 当 max_depth=7时，depth-wise 树可以达到较高的准确率.但是如果设置 num_leaves 为 128 时, 有可能会导致过拟合, 而将其设置为 70 或 80 时可能会得到比 depth-wise 树更高的准确率. 其实, depth 的概念在 leaf-wise 树中并没有多大作用, 因为并不存在一个从 leaves 到 depth 的合理映射。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）min_data_in_leaf. 这是处理 leaf-wise 树的过拟合问题中一个非常重要的参数. 它的值取决于训练数据的样本个树和 num_leaves. 将其设置的较大可以避免生成一个过深的树, 但有可能导致欠拟合. 实际应用中, 对于大数据集, 设置其为几百或几千就足够了。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）max_depth（默认不限制，一般设置该值为5—10即可） 你也可以利用 max_depth 来显式地限制树的深度。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">5.2 针对更快的训练速度</span></p><p><span style=\"\">（1）通过设置 bagging_fraction 和 bagging_freq 参数来使用 bagging 方法；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）通过设置 feature_fraction 参数来使用特征的子抽样；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）使用较小的 max_bin；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）使用 save_binary 在以后的学习过程对数据进行加速加载。</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">5.3 针对更好的准确率</span></p><p><span style=\"\">（1）使用较大的 max_bin （学习速度可能变慢）；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）使用较小的 learning_rate 和较大的 num_iterations；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）使用较大的 num_leaves （可能导致过拟合）；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）使用更大的训练数据；</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（5）尝试 dart（一种在多元Additive回归树种使用dropouts的算法）.</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">5.4 处理过拟合</span></p><p><span style=\"\">（1）使用较小的 max_bin（默认为255）</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）使用较小的 num_leaves（默认为31）</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（3）使用 min_data_in_leaf（默认为20） 和 min_sum_hessian_in_leaf（默认为）</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（4）通过设置 bagging_fraction （默认为1.0）和 bagging_freq （默认为0，意味着禁用bagging，k表示每k次迭代执行一个bagging）来使用 bagging</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（5）通过设置 feature_fraction（默认为1.0） 来使用特征子抽样</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（6）使用更大的训练数据</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（7）使用 lambda_l1（默认为0）, lambda_l2 （默认为0）和 min_split_gain（默认为0，表示执行切分的最小增益） 来使用正则</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（8）尝试 max_depth 来避免生成过深的树</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">六、参考文献</span></p><p><span style=\"\">（1）LightGBM: A Highly Efficient Gradient Boosting Decision Tree 论文</span></p><p><span style=\"\"><br></span><br></p><p><span style=\"\">（2）LightGBM官网</span></p><p><span style=\"\">---------------------&nbsp;</span></p><p><span style=\"\">作者：Y学习使我快乐V&nbsp;</span></p><p><span style=\"\">来源：CSDN&nbsp;</span></p><p><span style=\"\">原文：<a href=\"https://blog.csdn.net/qq_24519677/article/details/82811215\" rel=\"nofollow\">https://blog.csdn.net/qq_24519677/article/details/82811215</a>&nbsp;</span></p><p><span style=\"\">版权声明：本文为博主原创文章，转载请附上博文链接！</span></p>', '人工智能', '0', '2019-01-08 20:17:05', 8, 0, '0');
INSERT INTO `article` VALUES (28, 21, '图片上传示例', '<div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><p>333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333332222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111119999999999999999999999999999999999999999999999999999999999999988888888888888888888888888888888888888888888888888888777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555544444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444</p></div>', 'MySql', '0', '2019-01-12 22:33:48', 12, 0, '0');
INSERT INTO `article` VALUES (29, 21, 'JVM实用参数', '<div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. HotSpot JVM 提供了三类参数。</span></div><div><ul yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 2; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">第一类包括了标准参数。顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用 java -help）检索出所有标准参数。例如：-server，-client。</span></li><li style=\"line-height: 2; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">第二类是X参数，非标准化的参数在将来的版本中可能会改变。所有的这类参数都以-X开始，并且可以用java -X来检索。注意，不能保证所有参数都可以被检索出来，其中就没有-Xcomp。</span></li><li style=\"line-height: 2; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">第三类是包含XX参数（到目前为止最多的），它们同样不是标准的，甚至很长一段时间内不被列出来。（然而，在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中）</span></li></ul></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><span style=\"font-size: medium;\"><span style=\"font-family: Arial; font-weight: bold;\">2. 用一句话来说明XX参数的语法</span><span style=\"font-family: Arial;\">。</span><span style=\"font-family: Arial; font-weight: bold;\">所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。</span></span></div><div><ul yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 2; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+&lt;name&gt;用于激活&lt;name&gt;选项，而-XX:-&lt;name&gt;用于注销选项。</span></li><li style=\"line-height: 2; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”=”，最后赋值。例如， &nbsp;-XX:&lt;name&gt;=&lt;value&gt;给&lt;name&gt;赋值&lt;value&gt;。</span></li></ul></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. HotSpot&nbsp;JVM&nbsp;提供给了两个新的参数，在JVM启动后，在命令行中可以输出所有XX参数和值：</span></div><div><ul yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 2.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">-XX:+PrintFlagsFinal </span></li><li style=\"line-height: 2.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\"> -XX:+PrintFlagsInitial</span></li></ul></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">比如：以 -client 作为参数的 -XX:+PrintFlagsFinal：java -client -XX:+PrintFlagsFinal（表格的每一行包括五列，来表示一个XX参数。第一列表示参数的数据类型，第二列是名称，第四列为值，第五列是参数的类别。第三列”=”表示第四列是参数的默认值，而”:=” 表明了参数被用户或者JVM赋值了。）</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">打印所有XX参数及值</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">例如：java -client -XX:+PrintFlagsFinal 类名，表示以 -client 作为参数的 -XX:+PrintFlagsFinal表格的每一行包括五列，来表示一个XX参数。第一列表示参数的数据类型，第二列是名称，第四列为值，第五列是参数的类别。第三列”=”表示第四列是参数的默认值，而”:=” 表明了参数被用户或者JVM赋值了。如果我们只想看下所有XX参数的默认值，能够用一个相关的参数，-XX:+PrintFlagsInitial &nbsp;。 用&nbsp;-XX:+PrintFlagsInitial, 只是展示了第三列为“=”的数据（也包括那些被设置其他值的参数）。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX:+PrintCommandLineFlags</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">这个参数让JVM打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值。换句话说，它列举出</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+PrintFlagsFinal的结果中第三列有\":=\"的参数。以这种方式，我们可以用</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+PrintCommandLineFlags作为快捷方式来查看修改过的参数。看下面的例子：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><span style=\"font-size: medium;\"><span style=\"color: rgb(88, 89, 90); background-color: rgb(250, 250, 250);\">java </span><span style=\"color: rgb(102, 0, 51); background-color: rgb(250, 250, 250);\">-server</span><span style=\"color: rgb(88, 89, 90); background-color: rgb(250, 250, 250);\"> -XX:+PrintCommandLineFlags</span></span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">内存调优有关参数</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize，-Xms和-Xmx是其缩写)</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-Xms和-Xmx可以说是最流行的JVM参数，它们可以允许我们指定JVM的初始和最大堆内存大小。一般来说，这两个参数的数值单位是Byte，但同时它们也支持使用速记符号，比如“k”或者“K”，“m”或者“M”，“g”或者“G”。举个例子，下面的命令启动了一个初始化堆内存为128M，最大堆内存为2G，名叫“MyApp”的Java应用程序。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: &quot;Courier New&quot;; background-color: rgb(255, 255, 255); font-size: medium;\">java -Xms128m -Xmx2g MyApp</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">我们可以通过将“-Xms”和“-Xmx”设置为相同大小来获得一个固定大小的堆内存。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-size: medium;\"><span style=\"font-family: Arial; font-weight: bold;\"> </span><span style=\"font-family: Arial;\">我们可以通过设置-XX:+HeapDumpOnOutOfMemoryError&nbsp;让JVM在发生内存溢出时自动的生成堆内存快照。有了这个参数，当我们不得不面对内存溢出异常的时候会节约大量的时间。默认情况下，堆内存快照会保存在JVM的启动目录下名为java_pid&lt;pid&gt;.hprof&nbsp;的文件里（在这里&lt;pid&gt;就是JVM进程的进程号）。也可以通过设置</span></span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:HeapDumpPath=&lt;path&gt;来改变默认的堆内存快照生成路径，&lt;path&gt;可以是相对或者绝对路径。虽然这一切听起来很不错，但有一点我们需要牢记。堆内存快照文件有可能很庞大，特别是当内存溢出错误发生的时候。因此，我们推荐将堆内存快照生成路径指定到一个拥有足够磁盘空间的地方。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:OnOutOfMemoryError</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">当内存溢发生时，我们甚至可以执行一些指令，比如发个E-mail通知管理员或者执行一些清理工作。通过</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:OnOutOfMemoryError 这个参数我们可以做到这一点，这个参数可以接受一串指令和它们的参数。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">在下面的例子中，当内存溢出错误发生的时候，我们会将堆内存快照写到/tmp/heapdump.hprof 文件并且在JVM的运行目录执行脚本cleanup.sh</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><span style=\"font-size: medium;\"><span style=\"font-family: &quot;Courier New&quot;; background-color: rgb(255, 255, 255);\">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:OnOutOfMemoryError =</span><span style=\"font-family: &quot;Courier New&quot;; color: rgb(42, 0, 255); background-color: rgb(255, 255, 255);\">\"sh ~/cleanup.sh\"</span><span style=\"font-family: &quot;Courier New&quot;; background-color: rgb(255, 255, 255);\">&nbsp;MyApp</span></span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. &nbsp;-XX:PermSize and -XX:MaxPermSize</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">永久代在堆内存中是一块独立的区域，它包含了所有JVM加载的类的对象表示。为了成功运行应用程序，JVM会加载很多类（因为它们依赖于大量的第三方库，而这又依赖于更多的库并且需要从里面将类加载进来）这就需要增加永久代的大小。我们可以使用-XX:PermSize&nbsp;和-XX:MaxPermSize 来达到这个目的。下面是一个简单的例子：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2;\"><span style=\"font-family: &quot;Courier New&quot;; background-color: rgb(255, 255, 255); font-size: medium;\">java -XX:PermSize=128m -XX:MaxPermSize=256m MyApp</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">上面两个参数用来自定义代码缓存的大小</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">6. -XX:+UseCodeCacheFlushing</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">如果代码缓存不断增长，例如，因为热部署引起的内存泄漏，那么提高代码的缓存大小只会延缓其发生溢出。为了避免这种情况的发生，我们可以尝试一个有趣的新参数：当代码缓存被填满时让JVM放弃一些编译代码。通过使用-XX:+UseCodeCacheFlushing 这个参数，我们至少可以避免当代码缓存被填满的时候JVM切换到interpreted-only 模式。不过，我仍建议尽快解决代码缓存问题发生的根本原因，如找出内存泄漏并修复它。</span></div><div yne-bulb-block=\"heading\" yne-bulb-level=\"2\" id=\"3455-1551627120407\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">新生代有关的JVM参数</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX:NewSize and -XX:MaxNewSize</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">就像可以通过参数(-Xms and -Xmx) 指定堆大小一样，可以通过参数指定新生代大小。考虑到新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少。一般不允许新生代比老年代还大，因为要考虑GC时最坏情况，所有对象都晋升到老年代。 -XX:MaxNewSize 最大可以设置为-Xmx/2 .</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX:NewRatio</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">可以设置新生代和老年代的相对大小。这种方式的优点是新生代大小会随着整个堆大小动态扩展。参数 -XX:NewRatio 设置老年代与新生代的比例。例如 -XX:NewRatio=3 指定老年代/新生代为3/1. 老年代占堆大小的 3/4 ，新生代占 1/4 .</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:SurvivorRatio</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">指定Eden与幸存区大小比例. 例如, -XX:SurvivorRatio=10 表示Eden是 To Survivor 大小的10倍(也是From Survivor的10倍)。所以,Eden占新生代大小的10/12, From Survivor和To Survivor每个占新生代的1/12 .</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. -XX:+PrintTenuringDistribution</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">指定JVM 在每次新生代GC时，输出Survivor中对象的年龄分布</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold 和 -XX:TargetSurvivorRatio</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">通过 -XX:InitialTenuringThreshold 和 -XX:MaxTenuringThreshold 可以设定老年代阀值的初始值和最大值。另外,可以通过参数 -XX:TargetSurvivorRatio 设定幸存区的目标使用率.例如 , -XX:MaxTenuringThreshold=10 </span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:TargetSurvivorRatio=90 设定老年代阀值的上限为10,幸存区空间目标使用率为90%。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">有多种方式,设置新生代行为，没有通用准则。我们必须清楚以下2中情况：</span></div><div><ul yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 2.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">如果从年龄分布中发现，有很多对象的年龄持续增长，在到达老年代阀值之前。这表示 -XX:MaxTenuringThreshold 设置过大</span></li><li style=\"line-height: 2.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: disc; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent;\"><span style=\"font-size: medium;\">2如果 -XX:MaxTenuringThreshold 的值大于1，但是很多对象年龄从未大于1.应该看下幸存区的目标使用率。如果幸存区使用率从未到达，这表示对象都被GC回收，这正是我们想要的。 如果幸存区使用率经常达到，有些年龄超过1的对象被移动到老年代中。这种情况，可以尝试调整幸存区大小或目标使用率。</span></li></ul></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">6. -XX:+NeverTenure and -XX:+AlwaysTenure</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">设置参数 -XX:+NeverTenure , 对象永远不会晋升到老年代.当我们确定不需要老年代时，可以这样设置。这样设置风险很大,并且会浪费至少一半的堆内存。相反设置参数 -XX:+AlwaysTenure, 表示没有幸存区,所有对象在第一次GC时，会晋升到老年代。没有合理的场景使用这个参数。可以在测试环境中，看下这样设置会发生什么有趣的事.但是并不推荐使用这些参数。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">7. -XX:PretenureSizeThreshold</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">8. -XX:HandlePromotionFailure</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况。这个参数在JDK 6 Update 24之后就不再使用了，即永远默认为true。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">吞吐量收集器有关参数</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX:+UseSerialGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">我们使用该标志来激活串行垃圾收集器，例如单线程面向吞吐量垃圾收集器。 无论年轻代还是年老代都将只有一个线程执行垃圾收集。 该标志被推荐用于只有单个可用处理器核心的JVM。 在这种情况下，使用多个垃圾收集线程甚至会适得其反，因为这些线程将争用CPU资源，造成同步开销，却从未真正并行运行。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX:+UseParallelGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">有了这个标志，我们告诉JVM使用多线程并行执行年轻代垃圾收集。 在我看来，Java 6中不应该使用该标志因为</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+UseParallelOldGC显然更合适。 需要注意的是Java 7中该情况改变了一点，就是</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+UseParallelGC能达到 -XX:+UseParallelOldGC一样的效果。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:+UseParallelOldGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">该标志的命名有点不巧，因为”老”听起来像”过时”。 然而，”老”实际上是指年老代，这也解释了为什么</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+UseParallelOldGC要优于 -XX:+UseParallelGC：除了激活年轻代并行垃圾收集，也激活了年老代并行垃圾收集。 当期望高吞吐量，并且JVM有两个或更多可用处理器核心时，我建议使用该标志。-XX:+UseG1GC表示使用G1收集器</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. -XX:ParallelGCThreads</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">通过-XX:ParallelGCThreads=&lt;value&gt;我们可以指定并行垃圾收集的线程数量。 例如，-XX:ParallelGCThreads=6表示每次并行垃圾收集将有6个线程执行。 如果不明确设置该标志，虚拟机将使用基于可用(虚拟)处理器数量计算的默认值。 决定因素是由Java Runtime。availableProcessors()方法的返回值N，如果N&lt;=8，并行垃圾收集器将使用N个垃圾收集线程，如果N&gt;8个可用处理器，垃圾收集线程数量应为3+5N/8。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:GCTimeRatio</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">通过 -XX:GCTimeRatio=&lt;value&gt;我们告诉JVM吞吐量要达到的目标值。 更准确地说，-XX:GCTimeRatio=N 指定目标应用程序线程的执行时间(与总的程序执行时间)达到N/(N+1)的目标比值。 例如，通过 -XX:GCTimeRatio=9 我们要求应用程序线程在整个执行时间中至少9/10是活动的(因此，GC线程占用其余1/10)。 基于运行时的测量，JVM将会尝试修改堆和GC设置以期达到目标吞吐量。 -XX:GCTimeRatio 的默认值是99，也就是说，应用程序线程应该运行至少99%的总执行时间。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">6. -XX:MaxGCPauseMillis</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">通过-XX:GCTimeRatio=&lt;value&gt;告诉JVM最大暂停时间的目标值(以毫秒为单位)。该值仅在使用Parallel Scavenge收集器时生效。在运行时，吞吐量收集器计算在暂停期间观察到的统计数据(加权平均和标准偏差)。 如果统计表明正在经历的暂停其时间存在超过目标值的风险时，JVM会修改堆和GC设置以降低它们。 需要注意的是，年轻代和年老代垃圾收集的统计数据是分开计算的，还要注意，默认情况下，最大暂停时间没有被设置。如果最大暂停时间和最小吞吐量同时设置了目标值，实现最大暂停时间目标具有更高的优先级。 当然，无法保证JVM将一定能达到任一目标，即使它会努力去做。 最后，一切都取决于手头应用程序的行为。当设置最大暂停时间目标时，我们应注意不要选择太小的值。 正如我们现在所知道的，为了保持低暂停时间，JVM需要增加GC次数，那样可能会严重影响可达到的吞吐量。 这就是为什么对于要求低暂停时间作为主要目标的应用程序(大多数是Web应用程序)，我会建议不要使用吞吐量收集器，而是选择CMS收集器。 </span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">CMS收集器</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX：+UseConcMarkSweepGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">该标志首先是激活CMS收集器。默认HotSpot JVM使用的是并行收集器。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX：UseParNewGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">当使用CMS收集器时，该标志激活年轻代使用多线程并行执行垃圾回收。这令人很惊讶，我们不能简单在并行收集器中重用 -XX：UserParNewGC标志，因为概念上年轻代用的算法是一样的。然而，对于CMS收集器，年轻代GC算法和老年代GC算法是不同的，因此年轻代GC有两种不同的实现，并且是两个不同的标志。注意最新的JVM版本，当使用-XX：+UseConcMarkSweepGC时，-XX：UseParNewGC会自动开启。因此，如果年轻代的并行GC不想开启，可以通过设置-XX：-UseParNewGC来关掉。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:+CMSConcurrentMTEnabled</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">当该标志被启用时，并发的CMS阶段将以多线程执行(因此，多个GC线程会与所有的应用程序线程并行工作)。该标志已经默认开启，如果顺序执行更好，这取决于所使用的硬件，多线程执行可以通过 -XX:-CMSConcurremntMTEnabled禁用。 </span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. &nbsp;-XX：ConcGCThreads</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">标志 -XX:ConcGCThreads=&lt;value&gt; 定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。如果该标志未设置，JVM会根据并行收集器中的 -XX：ParallelGCThreads参数的值来计算出默认的并行CMS线程数。该公式是</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">ConcGCThreads = (ParallelGCThreads + 3)/4。因此，对于CMS收集器，&nbsp;-XX:ParallelGCThreads标志不仅影响“stop-the-world”垃圾收集阶段，还影响并发阶段。总之，有不少方法可以配置CMS收集器的多线程执行。正是由于这个原因,建议第一次运行CMS收集器时使用其默认设置, 然后如果需要调优再进行测试。只有在生产系统中测量(或类生产测试系统)发现应用程序的暂停时间的目标没有达到 , 就可以通过这些标志应该进行GC调优。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:CMSInitiatingOccupancyFraction</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:CMSInitiatingOccupancyFraction=&lt;value&gt;，该值代表老年代堆空间的使用率。比如，value=75意味着第一次CMS垃圾收集会在老年代被占用75%时被触发。在JDK1.6中，CMS收集器当老年代使用了68%的空间后就会被激活。在JDK1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Model Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 -XX:CMSInitiatingOccupancyFraction设置的太高很容易导致大量“Concurrent Model Failure”失败，性能反而降低。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">6. -XX：+UseCMSInitiatingOccupancyOnly</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">我们用-XX+UseCMSInitiatingOccupancyOnly标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">7. -XX:+CMSClassUnloadingEnabled</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">相对于并行收集器，CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，可用设置标志</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+CMSClassUnloadingEnabled。在早期JVM版本中，要求设置额外的标志</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">8.  -XX:+CMSIncrementalMode</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">该标志将开启CMS收集器的增量模式。增量模式经常暂停CMS过程，以便对应用程序线程作出完全的让步。因此，收集器将花更长的时间完成整个收集周期。因此，只有通过测试后发现正常CMS周期对应用程序线程干扰太大时，才应该使用增量模式。由于现代服务器有足够的处理器来适应并发的垃圾收集，所以这种情况发生得很少。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">9. -XX:+ExplicitGCInvokesConcurrent  和  -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">被广泛接受的最佳实践是避免显式地调用GC(所谓的“系统GC”)，即在应用程序中调用system.gc()。然而，这个建议是不管使用的GC算法的，值得一提的是，当使用CMS收集器时，系统GC将是一件很不幸的事，因为它默认会触发一次Full GC。幸运的是，有一种方式可以改变默认设置。标志-XX:+ExplicitGCInvokesConcurrent命令JVM无论什么时候调用系统GC，都执行CMS GC，而不是Full GC。第二个标志 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses保证当有系统GC调用时，永久代也被包括进CMS垃圾回收的范围内。因此，通过使用这些标志，我们可以防止出现意料之外的”stop-the-world”的系统GC。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">10. -XX:+DisableExplicitGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">该标志将告诉JVM完全忽略系统的GC调用(不管使用的收集器是什么类型)。对于我而言，该标志属于默认的标志集合中，可以安全地定义在每个JVM上运行，而不需要进一步思考。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">11. -XX:CMSFullGCsBeforeCompaction</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">由于CMS收集器不对内存空间进行压缩和整理，所以运行一段时间以后会产生\"碎片\",使得运行效率降低.此值设置运行多少次FULL GC以后对内存空间进行压缩，整理。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">12. -XX:+UseCMSCompactAtFullCollection</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">用于在CMS收集器顶不住要进行FULL GC时开启内存碎片的合并整合过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">GC日志有关参数</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX:+PrintGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">参数-XX:+PrintGC开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -XX:PrintGCDetails</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">开启详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:+PrintGCTimeStamps 和 -XX:+PrintGCDateStamps</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">使用-XX:+PrintGCTimeStamps可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳会被添加到每一行中。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">如果指定了-XX:+PrintGCDateStamps，每一行就添加上了绝对的日期和时间。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">如果需要也可以同时使用两个参数。推荐同时使用这两个参数，因为这样在关联不同来源的GC日志时很有帮助。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. -Xloggc</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">使用-Xloggc将日志输出到指定的文件。需要注意这个参数隐式的设置了参数</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:+PrintHeapAtGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">打印GC前后的详细堆栈信息</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; color: rgb(223, 64, 42); font-weight: bold; font-size: medium;\">其他</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">1. -XX:PermSize 和 -XX:MaxPermSize</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">设置持久代(perm gen)初始值和设置持久代最大值</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">2. -Xss</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">每个线程的堆栈大小</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">3. -XX:+UseBiasedLocking</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">锁机制的性能改善， 有偏见的锁是使得锁更偏爱上次使用到它线程。在非竞争锁的场景下，即只有一个线程会锁定对象，可以实现近乎无锁的开销。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">4. -Xnoclassgc</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">禁用类垃圾回收</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">5. -XX:+ScavengeBeforeFullGC</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">Full GC前调用YGC，默认为true</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">6. -XX:+UseAdaptiveSizePolicy</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-weight: bold; font-size: medium;\">7. -XX:MinHeapFreeRatio</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 2.5;\"><span style=\"font-family: Arial; font-size: medium;\">java堆中空闲量占的最小比例</span></div>', 'JVM', '0', '2019-01-13 20:28:36', 12, 0, '0');
INSERT INTO `article` VALUES (30, 21, '设计模式', '<div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">1. </span><span style=\"font-size: 16px; font-weight: bold;\">策略模式</span><span style=\"font-size: 16px;\">：</span>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。（将客户的同一类型的变化行为封装起来（接口），再通过组合进客户代码中，这样针对不同的行为，可以有不同的实现）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">策略模式示例程序类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/85a330e4debc4d308df34dbf48d7839d/clipboard.png\" style=\"width: 408px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">策略模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/ab0594612f554f3d8cfae46ddd5c6dd4/clipboard.png\" style=\"width: 320px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">策略模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">优点</div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">每个算法单独封装，减少了算法和算法调用者的耦合。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">合理使用继承有助于提取出算法中的公共部分。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">简化了单元测试。</li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\">缺点</div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">策略模式只适用于客户端知道所有的算法或行为的情况。</li><li style=\"line-height: 1.5; text-align: left; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: &quot;Microsoft YaHei&quot;, STXihei; color: rgb(0, 0, 0); background-color: transparent;\">策略模式造成很多的策略类，每个具体策略类都会产生一个新类。不过可以使用享元模式来减少对象的数量。</li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">2. 观察者模式：</span>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。（改变主题或观察者的一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由得改变他们。）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">观察者模式类图：</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/ec3f3abcf9b04187a39634649ad42158/clipboard.png\" style=\"width: 506px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">观察者模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">1. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，被观察者只知道所有具体观察者都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">2. 观察者模式实现了动态联动（联动：做一个操作引起其它相关操作）。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">3. 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">1. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\">2. <span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">3. 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">4. 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">3. 装饰者模式：</span>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（1）装饰者和被装饰对象有相同的超类型。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（2）你可以用一个或多个装饰者包装一个对象。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（3）既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">可以用装饰过的对象代替它。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（4）装饰者可以在所委托被装饰者的行为之前与<span style=\"font-size: 16px;\">/</span>或之后，加上自己的行为，以达到特定的目的。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">（5）对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">对象。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\">装饰者模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/219b415690f54cba8d88e10376213973/clipboard.png\" style=\"width: 436px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">装饰者模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">4. 工厂方法模式：</span>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\">工厂方法类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/c9925256325a4de899e3c82ac0793443/clipboard.png\" style=\"width: 445px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">工厂方法优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">良好的封装性，代码结构清晰，减少模块间的耦合。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">工厂方法模式的扩展性非常优秀。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">屏蔽产品类。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">工厂方法模式是典型的解耦框架。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">使用者必须知道相应工厂的存在。</span></li><li style=\"text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(255, 255, 255);\">每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255); font-weight: bold;\">5. 抽象工厂模式：</span>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">抽象工厂类图：</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/9344460efe044e3b8502eb57b9c143c3/clipboard.png\" style=\"width: 411px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/1a9e7ebe8d7f4a7b8494677206f0ce92/clipboard.png\" style=\"width: 395px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">抽象工厂的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">1.它分离了具体的类。</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">2.它使得易于交换产品系列</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-weight: bold;\">3.它有利于产品的一致性</span><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.5;\"><span style=\"font-size: 18px; font-family: Verdana; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">1. 抽象工厂模式在于难于应付“新对象”的需求变动，难以支持新种类的产品。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.71429;\"><span style=\"font-family: Arial; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">2. 难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">6. 单例模式：</span>确保一个类只有一个实例，并提供一个全局访问点。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">1、提供了对唯一实例的受控访问。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">2、单例类的职责过重，在一定程度上违背了“单一职责原则”。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; margin-left: 28px; line-height: 1.75;\">3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">7. 命令模式：</span>将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。（当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\">命令模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/3ece68937d2b4fccbbefc18f0de4a115/clipboard.png\" style=\"width: 466px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><br></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/864c4eae7fa84a36a11c0a84e418e022/image1.png\" style=\"width: 406px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">命令模式的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">（1）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更松散的耦合。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（2）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更动态的控制。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（3）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">很自然的复合命令。</span><span style=\"background-color: rgb(255, 255, 255);\">命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"background-color: rgb(255, 255, 255);\">　　（4）</span><span style=\"background-color: rgb(255, 255, 255); font-weight: bold;\">更好的扩展性。</span><span style=\"background-color: rgb(255, 255, 255);\">由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Verdana; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">（1）使用命令模式可能会导致某些系统有过多的具体命令类。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">8. 适配器模式：</span>将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">适配器模式类图：（1）使用继承  （2）使用委托</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">类图解释：Client不能直接使用adaptee需要使用适配器类Adapter才能使用，而适配器类Adapter实现了适配器接口（继承）。或者继承目标类而使用委托。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">（1）使用继承</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/8afb3b31e7c04288bf9ff56f44206812/clipboard.png\" style=\"width: 418px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">（2）使用委托</span></div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/899382c95f8f4511b7991c34ecb0921f/clipboard.png\" style=\"width: 406px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">   适配器模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">   优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（1）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">将目标类和适配者类解耦。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（2）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">增加了类的透明性和复用性。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一适配者类可以在多个不同的系统中复用。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（3）</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">灵活性和扩展性都非常好。</span><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上增加新的适配器，完全复合开闭原则。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　</span><span style=\"font-size: 16px; font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（1）一次最多只能适配一个适配者类，不能同时适配多个适配者。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">　　（2）目标抽象类只能为接口，不能为类，其使用有一定的局限性。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-family: Arial; background-color: rgb(255, 255, 255);\">（3）过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接								    口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Arial; background-color: rgb(255, 255, 255); font-weight: bold;\">9. 外观模式：</span>提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">外观模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/41c0a1148e8340778b18317f4d3dbdfd/clipboard.png\" style=\"width: 390px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">外观模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249); font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）外观模式对客户端屏蔽了子系统组件，从而简化了接口，减少了客户端处理的对象数目并使子系统的使用更加简单。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户端。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249); font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）</span><span style=\"font-size: 13px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);\">不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">10. 模板方法模式：</span>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。（这个模式的重点在于：提供一个算法，并让子类实现某些步骤）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">模板方法模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/f5dece2856e14e5dab983022e70fb93f/clipboard.png\" style=\"width: 395px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">模板方法优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">提高代码复用性和可扩展性：把认为不变部分的算法封装到父类实现，可变部分则可以通过继承来实现，很容易扩展。（封装不变部分，扩展可变部分）</span></li><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">实现了反向控制：通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制，符合“开闭原则”。</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div><ol yne-block-type=\"list\" style=\"margin-top: 0px; margin-bottom: 0px; margin-left: 0px;\"><li style=\"text-indent: 28px; text-align: left; line-height: 1.75; font-size: 13px; list-style-position: inside; white-space: pre-wrap; word-break: break-word; list-style-type: decimal; font-family: Verdana; color: rgb(17, 17, 17); background-color: transparent;\"><span style=\"background-color: rgb(251, 249, 249);\">引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。（但是更加的符合单一职责原则，使得类的内聚性得以提高）</span></li></ol></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">11. 迭代器模式：</span>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">迭代器模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/05c05f1f780e48ffbe1f2f8f139c0ea0/clipboard.png\" style=\"width: 397px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">迭代器模式的优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过下标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">12. 组合模式：</span>允许你见对象组合成树形结结构来表现\"整体/部分\"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">组合模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/bfe77a3183154b2eae7a709577898169/clipboard.png\" style=\"width: 403px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><span style=\"font-size: 16px;\">组合模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（4）更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">13. 状态模式：</span>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">状态模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/b0e896cc19d148b19ec6a534ddb5e280/clipboard.png\" style=\"width: 404px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px;\">状态模式优缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）封装了转换规则。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）枚举可能的状态，在枚举状态之前需要确定状态种类。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（4）允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（5）可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（1）状态模式的使用必然会增加系统类和对象的个数。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（2）状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。&nbsp;</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要					修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; line-height: 1.75;\"><span style=\"font-size: 16px; font-weight: bold;\">14. 代理模式：</span>为另一个对象提供一个替身或占位符以控制对这个对象的访问。（使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象）</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">代理模式类图：</div><div yne-bulb-block=\"image\" style=\"text-align: center; float: none;\"><img alt=\"\" src=\"C:/Users/Administrator/AppData/Local/YNote/data/qq11A7EDCEC60B3F846EFAD006356109B9/d56f1693341d4145a7413239dfd7e6ac/clipboard.png\" style=\"width: 428px;\"></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\">代理模式优缺点：</div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><span style=\"font-weight: bold;\">优点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-indent: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（1）</span><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">代理模式能将代理对象与真正被调用的对象分离，在一定程度上降低了系统的耦合度。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（2）</span><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他操作。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(251, 249, 249);\">（3）高扩展性：无论被代理对象如何改变，只要代理类和被代理类都实现了统一接口，都不同修改代理类，而且即使扩展了新的被代理类，代理类也可以使用，只要创建代理类的时候传入对应的被代理类对象。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; text-align: justify; text-indent: 28px; line-height: 1.75;\"><span style=\"font-weight: bold;\">缺点：</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（1）在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; margin-left: 28px; line-height: 1.75;\"><span style=\"font-size: 13px; font-family: Verdana; color: rgb(17, 17, 17); background-color: rgb(255, 255, 255);\">（2）增加了系统的复杂度。</span></div><div yne-bulb-block=\"paragraph\" style=\"white-space: pre-wrap; line-height: 1.75;\"><br></div>', 'Java开发', '0', '2019-01-13 20:38:10', 15, 0, '0');

-- ----------------------------
-- Table structure for blog_version
-- ----------------------------
DROP TABLE IF EXISTS `blog_version`;
CREATE TABLE `blog_version`  (
  `blog_ver_id` tinyint(3) UNSIGNED NOT NULL AUTO_INCREMENT,
  `blog_ver_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `blog_ver_content` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `blog_ver_time` datetime(0) DEFAULT NULL,
  PRIMARY KEY (`blog_ver_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_version
-- ----------------------------
INSERT INTO `blog_version` VALUES (1, '第一版本', '没有信息', NULL);

-- ----------------------------
-- Table structure for child_comment
-- ----------------------------
DROP TABLE IF EXISTS `child_comment`;
CREATE TABLE `child_comment`  (
  `child_id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `c_id` bigint(20) DEFAULT NULL,
  `by_id` bigint(20) DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `create_time` datetime(0) DEFAULT NULL,
  PRIMARY KEY (`child_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 34 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of child_comment
-- ----------------------------
INSERT INTO `child_comment` VALUES (24, 1, 19, '666', '2018-12-24 21:08:42');
INSERT INTO `child_comment` VALUES (25, 16, 19, '666', '2018-12-24 21:11:26');
INSERT INTO `child_comment` VALUES (26, 6, 21, '666', '2018-12-24 21:19:28');
INSERT INTO `child_comment` VALUES (27, 39, 21, '666', '2018-12-24 21:20:23');
INSERT INTO `child_comment` VALUES (28, 39, 21, '666', '2018-12-24 21:20:30');
INSERT INTO `child_comment` VALUES (29, 40, 21, '555', '2018-12-24 21:20:57');
INSERT INTO `child_comment` VALUES (30, 2, 21, '666', '2019-01-04 23:02:47');
INSERT INTO `child_comment` VALUES (31, 3, 19, '666', '2019-01-04 23:38:52');
INSERT INTO `child_comment` VALUES (32, 21, 19, '66', '2019-01-04 23:39:42');
INSERT INTO `child_comment` VALUES (33, 10, 19, '你好', '2019-01-04 23:40:07');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `c_id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `a_id` bigint(20) DEFAULT NULL,
  `by_id` bigint(20) DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `create_time` datetime(0) DEFAULT NULL,
  PRIMARY KEY (`c_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 42 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 8, 19, '写的真好，收获很大', '2018-12-19 20:42:31');
INSERT INTO `comment` VALUES (2, 8, 21, '不错哟', '2018-12-22 12:38:31');
INSERT INTO `comment` VALUES (3, 8, 21, '测试', '2018-12-22 16:26:34');
INSERT INTO `comment` VALUES (6, 3, 21, '你好', '2018-12-22 18:54:26');
INSERT INTO `comment` VALUES (10, 3, 19, '测试', '2018-12-22 19:08:11');
INSERT INTO `comment` VALUES (16, 3, 19, '不会', '2018-12-22 20:29:05');
INSERT INTO `comment` VALUES (21, 8, 21, '学习使我快乐', '2018-12-22 22:23:06');
INSERT INTO `comment` VALUES (32, 4, 19, '测试', '2018-12-22 23:14:34');
INSERT INTO `comment` VALUES (33, 4, 19, 'hello', '2018-12-22 23:16:50');
INSERT INTO `comment` VALUES (34, 4, 19, '你是谁', '2018-12-22 23:17:31');
INSERT INTO `comment` VALUES (35, 3, 21, '我靠', '2018-12-23 23:22:59');
INSERT INTO `comment` VALUES (36, 1, 19, '班主任', '2018-12-23 23:53:59');
INSERT INTO `comment` VALUES (37, 1, 21, '你哄', '2018-12-24 13:40:47');
INSERT INTO `comment` VALUES (38, 1, 19, '乐乐', '2018-12-24 20:19:54');
INSERT INTO `comment` VALUES (39, 3, 21, '666', '2018-12-24 21:19:38');
INSERT INTO `comment` VALUES (40, 3, 21, '666', '2018-12-24 21:20:40');
INSERT INTO `comment` VALUES (41, 3, 19, '好样的', '2019-01-04 23:40:33');

-- ----------------------------
-- Table structure for friend_link
-- ----------------------------
DROP TABLE IF EXISTS `friend_link`;
CREATE TABLE `friend_link`  (
  `link_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `link_content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `link_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`link_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of friend_link
-- ----------------------------
INSERT INTO `friend_link` VALUES (2, '学习使我快乐的CSDN博客', 'https://blog.csdn.net/qq_24519677');
INSERT INTO `friend_link` VALUES (3, 'layui官网', 'https://www.layui.com/');

-- ----------------------------
-- Table structure for res_child
-- ----------------------------
DROP TABLE IF EXISTS `res_child`;
CREATE TABLE `res_child`  (
  `child_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `child_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `introduction` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `pass` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_time` datetime(0) DEFAULT NULL,
  `fk_parent_id` int(10) UNSIGNED DEFAULT NULL,
  PRIMARY KEY (`child_id`) USING BTREE,
  INDEX `fk_parent_id`(`fk_parent_id`) USING BTREE,
  CONSTRAINT `res_child_ibfk_1` FOREIGN KEY (`fk_parent_id`) REFERENCES `res_parent` (`parent_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of res_child
-- ----------------------------
INSERT INTO `res_child` VALUES (8, '数据库视频', 'Redis视频教程', 'https://pan.baidu.com/s/1Z-rctErZGzXJSDqE5Lgi8w', '8dhg', '2019-01-16 11:38:52', 1);
INSERT INTO `res_child` VALUES (9, '数据库视频', 'Mongodb视频教程', 'https://pan.baidu.com/s/1v0E3moiZlh-m7UAhn--qDA', 'e0dq', '2019-01-16 11:40:12', 1);
INSERT INTO `res_child` VALUES (10, '数据库视频', '数据仓库Hive视频教程', 'https://pan.baidu.com/s/1m8YHofze1EW-Mact-_HeFg', '5u2d', '2019-01-16 11:41:29', 1);
INSERT INTO `res_child` VALUES (11, '数据库书籍', '《MySQL 5.7 从入门到精通》书籍', 'https://pan.baidu.com/s/1CnRn6kwzxxPKqkADUqotOQ', 'whb7', '2019-01-16 11:42:52', 2);
INSERT INTO `res_child` VALUES (12, '数据库书籍', '《深入浅出MySQL》数据库开发、优化与管理维护书籍', 'https://pan.baidu.com/s/1ms6BEvhPCb0BBEqEPafdCg', 'lkqm', '2019-01-16 11:44:44', 2);

-- ----------------------------
-- Table structure for res_parent
-- ----------------------------
DROP TABLE IF EXISTS `res_parent`;
CREATE TABLE `res_parent`  (
  `parent_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `parent_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of res_parent
-- ----------------------------
INSERT INTO `res_parent` VALUES (1, '视频');
INSERT INTO `res_parent` VALUES (2, '电子书');
INSERT INTO `res_parent` VALUES (4, '代码');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `phone` char(11) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `img_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `update_time` datetime(0) NOT NULL,
  `create_time` datetime(0) NOT NULL,
  `state` char(1) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `admin` char(1) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 47 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'xyq@qq.com', '14755588678', 'xyq', '123456', '', '2019-06-22 18:12:06', '2019-06-22 18:12:09', '0', '0', 'yi', NULL);
INSERT INTO `user` VALUES (2, 'yxl@qq.com', '13855588678', 'yxl', '123456', NULL, '2019-06-22 18:14:56', '2019-06-22 18:14:59', '0', '0', 'yu', '');
INSERT INTO `user` VALUES (8, '213@qq.com', NULL, '博科·', '212112', NULL, '2019-07-02 21:30:27', '2019-07-02 21:30:29', '1', '0', '1', '杭州');
INSERT INTO `user` VALUES (19, '206288258@qq.com', '14755588678', '博客1360', '1231231', NULL, '2019-07-03 16:11:23', '2019-07-03 16:11:27', '1', '0', '1', '西湖');
INSERT INTO `user` VALUES (21, '453055044@qq.com', NULL, 'xyq', '5555555555', NULL, '2019-07-03 16:14:35', '2019-07-03 16:14:38', '1', '0', '1', '西湖');
INSERT INTO `user` VALUES (41, '2062882581@qq.com', NULL, '博客1562052614551', '{bcrypt}$2a$10$46jWqxcQd3uBK8ZpJHI.F..8/wyNK4yoZMUbI9S0qGCcpOvlO/hhi', NULL, '2019-07-02 15:30:15', '2019-07-02 15:30:15', '1', '0', '对方很懒，没有留下简介', '江苏-杭州');
INSERT INTO `user` VALUES (42, '13262@qq.com', NULL, '博客', '123456', NULL, '2019-07-02 21:25:04', '2019-07-02 21:25:07', '0', '0', '1', '杭州');
INSERT INTO `user` VALUES (43, '12@qq.com', NULL, '博客2', '121212', NULL, '2019-07-02 21:26:54', '2019-07-02 21:26:56', '0', '0', '1', '杭州');
INSERT INTO `user` VALUES (44, '23@qq.com', NULL, '博客3 ', '121212', NULL, '2019-07-02 21:27:42', '2019-07-02 21:27:44', '0', '1', '1', '杭州');
INSERT INTO `user` VALUES (45, '323@qq.com', NULL, '博科4 ', '121212', NULL, '2019-07-02 21:28:20', '2019-07-02 21:28:23', '1', '0', '1', '杭州');
INSERT INTO `user` VALUES (46, '323@qq.com', NULL, '博科4 ', '121212', NULL, '2019-07-02 21:28:20', '2019-07-02 21:28:23', '1', '0', '1', '杭州');

SET FOREIGN_KEY_CHECKS = 1;
